
Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf02.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf02"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf02 = _halide_buffer_get_host(buf02.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input03_b2[float64 * 320 * 64 * 64]
  allocate _input01_b1[float64 * 320]
  allocate _icomp00_b0[float64 * 64 * 64]
  allocate _comp01_b4[float64 * 320 * 64 * 64]
  allocate _comp00_b3[float64 * 320 * 64 * 64]
  for (c1, 0, 64) {
    for (c3, 0, 64) {
      for (c5, 0, 320) {
        buf00[(c3 + int32((int64(c1)*(int64)64)))] = ((1.000000 - (buf01[c5]*1.260000))*buf00[(c3 + int32((int64(c1)*(int64)64)))])
      }
      for (c5, 0, 320) {
        buf02[((c5 + int32((int64(c3)*(int64)320))) + int32((int64(c1)*(int64)20480)))] = (buf00[(c3 + int32((int64(c1)*(int64)64)))] + buf03[((c5 + int32((int64(c3)*(int64)320))) + int32((int64(c1)*(int64)20480)))])
      }
    }
  }
}
Initial exec time : 1.244480
Schedule measurements timeout set to 3.000000*3(MAX_RUNS) s

-----------
Matrix Transform 3x3 {comp00, } [1, 0, 0, 0, 1, 0, 0, 0, 1]
Matrix Transform 3x3 {comp01, } [1, 0, 0, 0, 1, 0, 0, 0, 1]
Matrix Transform 2x2 {comp00, comp01, } [0, 1, 1, 0]
0- for 0 <= i0 < 64 | 0
	1- for 0 <= i1 < 64 | 0
		2- for 0 <= i2 < 320 | 0
			comp00
		2- for 0 <= i3 < 320 | 0
			comp01
{ comp00[t10, t11, t12] -> comp00[0, 0, t34 = t11, 0, t35 = t10, 0, t36 = t12, 0] : 0 <= t10 <= 63 and 0 <= t11 <= 63 and 0 <= t12 <= 319 }{ comp01[t14, t15, t16] -> comp01[0, 0, t37 = t15, 0, t38 = t14, 10, t39 = t16, 0] : 0 <= t14 <= 63 and 0 <= t15 <= 63 and 0 <= t16 <= 319 }
<legal>



input01:0 0 1 0 ,
icomp00:1 0 0 0 ,0 1 0 0 ,

icomp00:1 0 0 0 ,0 1 0 0 ,
input03:1 0 0 0 ,0 1 0 0 ,0 0 1 0 ,

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf02.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf02"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf02 = _halide_buffer_get_host(buf02.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input03_b2[float64 * 320 * 64 * 64]
  allocate _input01_b1[float64 * 320]
  allocate _icomp00_b0[float64 * 64 * 64]
  allocate _comp01_b4[float64 * 320 * 64 * 64]
  allocate _comp00_b3[float64 * 320 * 64 * 64]
  for (c1, 0, 64) {
    for (c3, 0, 64) {
      for (c5, 0, 320) {
        buf00[(c1 + int32((int64(c3)*(int64)64)))] = ((1.000000 - (buf01[c5]*1.260000))*buf00[(c1 + int32((int64(c3)*(int64)64)))])
      }
      for (c5, 0, 320) {
        buf02[((c5 + int32((int64(c1)*(int64)320))) + int32((int64(c3)*(int64)20480)))] = (buf00[(c1 + int32((int64(c3)*(int64)64)))] + buf03[((c5 + int32((int64(c1)*(int64)320))) + int32((int64(c3)*(int64)20480)))])
      }
    }
  }
}
{ comp00[t10, t11, t12] -> comp00[0, 0, t34 = t11, 0, t35 = t10, 0, t36 = t12, 0] : 0 <= t10 <= 63 and 0 <= t11 <= 63 and 0 <= t12 <= 319 }{ comp01[t14, t15, t16] -> comp01[0, 0, t37 = t15, 0, t38 = t14, 10, t39 = t16, 0] : 0 <= t14 <= 63 and 0 <= t15 <= 63 and 0 <= t16 <= 319 }
<legal>



input01:0 0 1 0 ,
icomp00:1 0 0 0 ,0 1 0 0 ,

icomp00:1 0 0 0 ,0 1 0 0 ,
input03:1 0 0 0 ,0 1 0 0 ,0 0 1 0 ,
Schedule number 2
Evaluation : 1.264730
Number of measurements : 3
===================================


-----------
Matrix Transform 3x3 {comp00, } [1, 0, 0, 0, 1, 0, 0, 0, 1]
Matrix Transform 3x3 {comp01, } [1, 0, 0, 0, 1, 0, 0, 0, 1]
Matrix Transform 2x2 {comp00, comp01, } [-1, 0, 0, 1]
0- for -63 <= i0 < 1 | 0
	1- for 0 <= i1 < 64 | 0
		2- for 0 <= i2 < 320 | 0
			comp00
		2- for 0 <= i3 < 320 | 0
			comp01
{ comp00[t10, t11, t12] -> comp00[0, 0, t48 = -t10, 0, t49 = t11, 0, t50 = t12, 0] : 0 <= t10 <= 63 and 0 <= t11 <= 63 and 0 <= t12 <= 319 }{ comp01[t14, t15, t16] -> comp01[0, 0, t51 = -t14, 0, t52 = t15, 10, t53 = t16, 0] : 0 <= t14 <= 63 and 0 <= t15 <= 63 and 0 <= t16 <= 319 }
<legal>



input01:0 0 1 0 ,
icomp00:1 0 0 0 ,0 1 0 0 ,

icomp00:1 0 0 0 ,0 1 0 0 ,
input03:1 0 0 0 ,0 1 0 0 ,0 0 1 0 ,

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf02.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf02"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf02 = _halide_buffer_get_host(buf02.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input03_b2[float64 * 320 * 64 * 64]
  allocate _input01_b1[float64 * 320]
  allocate _icomp00_b0[float64 * 64 * 64]
  allocate _comp01_b4[float64 * 320 * 64 * 64]
  allocate _comp00_b3[float64 * 320 * 64 * 64]
  for (c1, -63, 64) {
    for (c3, 0, 64) {
      for (c5, 0, 320) {
        buf00[(c3 + int32((int64((0 - c1))*(int64)64)))] = ((1.000000 - (buf01[c5]*1.260000))*buf00[(c3 + int32((int64((0 - c1))*(int64)64)))])
      }
      for (c5, 0, 320) {
        buf02[((c5 + int32((int64(c3)*(int64)320))) + int32((int64((0 - c1))*(int64)20480)))] = (buf00[(c3 + int32((int64((0 - c1))*(int64)64)))] + buf03[((c5 + int32((int64(c3)*(int64)320))) + int32((int64((0 - c1))*(int64)20480)))])
      }
    }
  }
}
{ comp00[t10, t11, t12] -> comp00[0, 0, t48 = -t10, 0, t49 = t11, 0, t50 = t12, 0] : 0 <= t10 <= 63 and 0 <= t11 <= 63 and 0 <= t12 <= 319 }{ comp01[t14, t15, t16] -> comp01[0, 0, t51 = -t14, 0, t52 = t15, 10, t53 = t16, 0] : 0 <= t14 <= 63 and 0 <= t15 <= 63 and 0 <= t16 <= 319 }
<legal>



input01:0 0 1 0 ,
icomp00:1 0 0 0 ,0 1 0 0 ,

icomp00:1 0 0 0 ,0 1 0 0 ,
input03:1 0 0 0 ,0 1 0 0 ,0 0 1 0 ,
Schedule number 3
Evaluation : 1.774190
Number of measurements : 3
===================================


-----------
Matrix Transform 3x3 {comp00, } [1, 0, 0, 0, 1, 0, 0, 0, 1]
Matrix Transform 3x3 {comp01, } [1, 0, 0, 0, 1, 0, 0, 0, 1]
Matrix Transform 2x2 {comp00, comp01, } [1, 0, 0, -1]
0- for 0 <= i0 < 64 | 0
	1- for -63 <= i1 < 1 | 0
		2- for 0 <= i2 < 320 | 0
			comp00
		2- for 0 <= i3 < 320 | 0
			comp01
{ comp00[t10, t11, t12] -> comp00[0, 0, t62 = t10, 0, t63 = -t11, 0, t64 = t12, 0] : 0 <= t10 <= 63 and 0 <= t11 <= 63 and 0 <= t12 <= 319 }{ comp01[t14, t15, t16] -> comp01[0, 0, t65 = t14, 0, t66 = -t15, 10, t67 = t16, 0] : 0 <= t14 <= 63 and 0 <= t15 <= 63 and 0 <= t16 <= 319 }
<legal>



input01:0 0 1 0 ,
icomp00:1 0 0 0 ,0 1 0 0 ,

icomp00:1 0 0 0 ,0 1 0 0 ,
input03:1 0 0 0 ,0 1 0 0 ,0 0 1 0 ,

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf02.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf02"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf02 = _halide_buffer_get_host(buf02.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input03_b2[float64 * 320 * 64 * 64]
  allocate _input01_b1[float64 * 320]
  allocate _icomp00_b0[float64 * 64 * 64]
  allocate _comp01_b4[float64 * 320 * 64 * 64]
  allocate _comp00_b3[float64 * 320 * 64 * 64]
  for (c1, 0, 64) {
    for (c3, -63, 64) {
      for (c5, 0, 320) {
        buf00[(int32((int64(c1)*(int64)64)) - c3)] = ((1.000000 - (buf01[c5]*1.260000))*buf00[(int32((int64(c1)*(int64)64)) - c3)])
      }
      for (c5, 0, 320) {
        buf02[((c5 + int32((int64((0 - c3))*(int64)320))) + int32((int64(c1)*(int64)20480)))] = (buf00[(int32((int64(c1)*(int64)64)) - c3)] + buf03[((c5 + int32((int64((0 - c3))*(int64)320))) + int32((int64(c1)*(int64)20480)))])
      }
    }
  }
}
{ comp00[t10, t11, t12] -> comp00[0, 0, t62 = t10, 0, t63 = -t11, 0, t64 = t12, 0] : 0 <= t10 <= 63 and 0 <= t11 <= 63 and 0 <= t12 <= 319 }{ comp01[t14, t15, t16] -> comp01[0, 0, t65 = t14, 0, t66 = -t15, 10, t67 = t16, 0] : 0 <= t14 <= 63 and 0 <= t15 <= 63 and 0 <= t16 <= 319 }
<legal>



input01:0 0 1 0 ,
icomp00:1 0 0 0 ,0 1 0 0 ,

icomp00:1 0 0 0 ,0 1 0 0 ,
input03:1 0 0 0 ,0 1 0 0 ,0 0 1 0 ,
Schedule number 4
Evaluation : 1.257690
Number of measurements : 3
===================================


-----------
Matrix Transform 3x3 {comp00, } [1, 0, 0, 0, 1, 0, 0, 0, 1]
Matrix Transform 3x3 {comp01, } [1, 0, 0, 0, 1, 0, 0, 0, 1]
Matrix Transform 3x3 {comp00, } [1, 0, 0, 0, 1, 0, 0, 0, -1]
0- for 0 <= i0 < 64 | 0
	1- for 0 <= i1 < 64 | 0
		2- for -319 <= i2 < 1 | 0
			comp00
		2- for 0 <= i3 < 320 | 0
			comp01
{ comp00[t10, t11, t12] -> comp00[0, 0, t72 = t10, 0, t73 = t11, 0, t74 = -t12, 0] : 0 <= t10 <= 63 and 0 <= t11 <= 63 and 0 <= t12 <= 319 }{ comp01[t14, t15, t16] -> comp01[0, 0, i0 = t14, 0, i1 = t15, 10, i3 = t16, 0] : 0 <= t14 <= 63 and 0 <= t15 <= 63 and 0 <= t16 <= 319 }
<illegal>

-----------
Matrix Transform 3x3 {comp00, } [1, 0, 0, 0, 1, 0, 0, 0, 1]
Matrix Transform 3x3 {comp01, } [1, 0, 0, 0, 1, 0, 0, 0, 1]
Matrix Transform 3x3 {comp01, } [1, 0, 0, 0, 1, 0, 0, 0, -1]
0- for 0 <= i0 < 64 | 0
	1- for 0 <= i1 < 64 | 0
		2- for 0 <= i2 < 320 | 0
			comp00
		2- for -319 <= i3 < 1 | 0
			comp01
{ comp00[t10, t11, t12] -> comp00[0, 0, i0 = t10, 0, i1 = t11, 0, i2 = t12, 0] : 0 <= t10 <= 63 and 0 <= t11 <= 63 and 0 <= t12 <= 319 }{ comp01[t14, t15, t16] -> comp01[0, 0, t79 = t14, 0, t80 = t15, 10, t81 = -t16, 0] : 0 <= t14 <= 63 and 0 <= t15 <= 63 and 0 <= t16 <= 319 }
<legal>



input01:0 0 1 0 ,
icomp00:1 0 0 0 ,0 1 0 0 ,

icomp00:1 0 0 0 ,0 1 0 0 ,
input03:1 0 0 0 ,0 1 0 0 ,0 0 1 0 ,

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf02.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf02"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf02 = _halide_buffer_get_host(buf02.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input03_b2[float64 * 320 * 64 * 64]
  allocate _input01_b1[float64 * 320]
  allocate _icomp00_b0[float64 * 64 * 64]
  allocate _comp01_b4[float64 * 320 * 64 * 64]
  allocate _comp00_b3[float64 * 320 * 64 * 64]
  for (c1, 0, 64) {
    for (c3, 0, 64) {
      for (c5, 0, 320) {
        buf00[(c3 + int32((int64(c1)*(int64)64)))] = ((1.000000 - (buf01[c5]*1.260000))*buf00[(c3 + int32((int64(c1)*(int64)64)))])
      }
      for (c5, -319, 320) {
        buf02[((int32((int64(c3)*(int64)320)) - c5) + int32((int64(c1)*(int64)20480)))] = (buf00[(c3 + int32((int64(c1)*(int64)64)))] + buf03[((int32((int64(c3)*(int64)320)) - c5) + int32((int64(c1)*(int64)20480)))])
      }
    }
  }
}
{ comp00[t10, t11, t12] -> comp00[0, 0, i0 = t10, 0, i1 = t11, 0, i2 = t12, 0] : 0 <= t10 <= 63 and 0 <= t11 <= 63 and 0 <= t12 <= 319 }{ comp01[t14, t15, t16] -> comp01[0, 0, t79 = t14, 0, t80 = t15, 10, t81 = -t16, 0] : 0 <= t14 <= 63 and 0 <= t15 <= 63 and 0 <= t16 <= 319 }
<legal>



input01:0 0 1 0 ,
icomp00:1 0 0 0 ,0 1 0 0 ,

icomp00:1 0 0 0 ,0 1 0 0 ,
input03:1 0 0 0 ,0 1 0 0 ,0 0 1 0 ,
Schedule number 5
Evaluation : 1.325950
Number of measurements : 3
===================================

parallelization unrolling: .*P\(\{(C[0-9],)*C0(,C[0-9])*\},L2\)U.*|.*P\(\{(C[0-9],)*C1(,C[0-9])*\},L2\)U.*
parallelization tiling: .*P\(\{(C[0-9],)*C0(,C[0-9])*\},L2\)T2\(\{(C[0-9],)*C0(,C[0-9])*\},L0,L1.*|.*P\(\{(C[0-9],)*C1(,C[0-9])*\},L2\)T2\(\{(C[0-9],)*C1(,C[0-9])*\},L0,L1.*
else
transform_ast

-----------
Matrix Transform 3x3 {comp00, } [1, 0, 0, 0, 1, 0, 0, 0, 1]
Matrix Transform 3x3 {comp01, } [1, 0, 0, 0, 1, 0, 0, 0, 1]
Parallelize L0 { comp00, comp01, }
0- for 0 <= i0 < 64 | 0 | P
	1- for 0 <= i1 < 64 | 0
		2- for 0 <= i2 < 320 | 0
			comp00
		2- for 0 <= i3 < 320 | 0
			comp01

<legal>

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf02.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf02"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf02 = _halide_buffer_get_host(buf02.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input03_b2[float64 * 320 * 64 * 64]
  allocate _input01_b1[float64 * 320]
  allocate _icomp00_b0[float64 * 64 * 64]
  allocate _comp01_b4[float64 * 320 * 64 * 64]
  allocate _comp00_b3[float64 * 320 * 64 * 64]
  parallel (c1, 0, 64) {
    for (c3, 0, 64) {
      for (c5, 0, 320) {
        buf00[(c3 + int32((int64(c1)*(int64)64)))] = ((1.000000 - (buf01[c5]*1.260000))*buf00[(c3 + int32((int64(c1)*(int64)64)))])
      }
      for (c5, 0, 320) {
        buf02[((c5 + int32((int64(c3)*(int64)320))) + int32((int64(c1)*(int64)20480)))] = (buf00[(c3 + int32((int64(c1)*(int64)64)))] + buf03[((c5 + int32((int64(c3)*(int64)320))) + int32((int64(c1)*(int64)20480)))])
      }
    }
  }
}

<legal>
Schedule number 6
Evaluation : 1.226150
Number of measurements : 3
===================================

parallelization unrolling: .*P\(\{(C[0-9],)*C0(,C[0-9])*\},L2\)U.*|.*P\(\{(C[0-9],)*C1(,C[0-9])*\},L2\)U.*
parallelization tiling: .*P\(\{(C[0-9],)*C0(,C[0-9])*\},L2\)T2\(\{(C[0-9],)*C0(,C[0-9])*\},L0,L1.*|.*P\(\{(C[0-9],)*C1(,C[0-9])*\},L2\)T2\(\{(C[0-9],)*C1(,C[0-9])*\},L0,L1.*
else
transform_ast

-----------
Matrix Transform 3x3 {comp00, } [1, 0, 0, 0, 1, 0, 0, 0, 1]
Matrix Transform 3x3 {comp01, } [1, 0, 0, 0, 1, 0, 0, 0, 1]
Parallelize L1 { comp00, comp01, }
0- for 0 <= i0 < 64 | 0
	1- for 0 <= i1 < 64 | 0 | P
		2- for 0 <= i2 < 320 | 0
			comp00
		2- for 0 <= i3 < 320 | 0
			comp01

<legal>

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf02.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf02"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf02 = _halide_buffer_get_host(buf02.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input03_b2[float64 * 320 * 64 * 64]
  allocate _input01_b1[float64 * 320]
  allocate _icomp00_b0[float64 * 64 * 64]
  allocate _comp01_b4[float64 * 320 * 64 * 64]
  allocate _comp00_b3[float64 * 320 * 64 * 64]
  for (c1, 0, 64) {
    parallel (c3, 0, 64) {
      for (c5, 0, 320) {
        buf00[(c3 + int32((int64(c1)*(int64)64)))] = ((1.000000 - (buf01[c5]*1.260000))*buf00[(c3 + int32((int64(c1)*(int64)64)))])
      }
      for (c5, 0, 320) {
        buf02[((c5 + int32((int64(c3)*(int64)320))) + int32((int64(c1)*(int64)20480)))] = (buf00[(c3 + int32((int64(c1)*(int64)64)))] + buf03[((c5 + int32((int64(c3)*(int64)320))) + int32((int64(c1)*(int64)20480)))])
      }
    }
  }
}

<legal>
Schedule number 7
Evaluation : 1.218340
Number of measurements : 3
===================================

parallelization unrolling: .*P\(\{(C[0-9],)*C0(,C[0-9])*\},L2\)U.*|.*P\(\{(C[0-9],)*C1(,C[0-9])*\},L2\)U.*
parallelization tiling: .*P\(\{(C[0-9],)*C0(,C[0-9])*\},L2\)T2\(\{(C[0-9],)*C0(,C[0-9])*\},L0,L1.*|.*P\(\{(C[0-9],)*C1(,C[0-9])*\},L2\)T2\(\{(C[0-9],)*C1(,C[0-9])*\},L0,L1.*
else
transform_ast

-----------
Matrix Transform 3x3 {comp00, } [1, 0, 0, 0, 1, 0, 0, 0, 1]
Matrix Transform 3x3 {comp01, } [1, 0, 0, 0, 1, 0, 0, 0, 1]
Parallelize L2 { comp01, }
0- for 0 <= i0 < 64 | 0
	1- for 0 <= i1 < 64 | 0
		2- for 0 <= i2 < 320 | 0
			comp00
		2- for 0 <= i3 < 320 | 0 | P
			comp01

<legal>
set to default

<legal>
Schedule number 8
Evaluation : 0.000000
Number of measurements : 1
===================================

parallelization unrolling: .*P\(\{(C[0-9],)*C0(,C[0-9])*\},L2\)U.*|.*P\(\{(C[0-9],)*C1(,C[0-9])*\},L2\)U.*
parallelization tiling: .*P\(\{(C[0-9],)*C0(,C[0-9])*\},L2\)T2\(\{(C[0-9],)*C0(,C[0-9])*\},L0,L1.*|.*P\(\{(C[0-9],)*C1(,C[0-9])*\},L2\)T2\(\{(C[0-9],)*C1(,C[0-9])*\},L0,L1.*
if

-----------
Matrix Transform 3x3 {comp00, } [1, 0, 0, 0, 1, 0, 0, 0, 1]
Matrix Transform 3x3 {comp01, } [1, 0, 0, 0, 1, 0, 0, 0, 1]
Parallelize L2 { comp01, }
Tiling L0 32 L1 32 { comp00, comp01, }
0- for 0 <= i0 < 64 | 0
	1- for 0 <= i1 < 64 | 0
		2- for 0 <= i2 < 320 | 0
			comp00
		2- for 0 <= i3 < 320 | 0 | P
			comp01

<Schedule pruned>
parallelization unrolling: .*P\(\{(C[0-9],)*C0(,C[0-9])*\},L2\)U.*|.*P\(\{(C[0-9],)*C1(,C[0-9])*\},L2\)U.*
if

-----------
Matrix Transform 3x3 {comp00, } [1, 0, 0, 0, 1, 0, 0, 0, 1]
Matrix Transform 3x3 {comp01, } [1, 0, 0, 0, 1, 0, 0, 0, 1]
Parallelize L2 { comp01, }
Unrolling L2 4 { comp00, }
0- for 0 <= i0 < 64 | 0
	1- for 0 <= i1 < 64 | 0
		2- for 0 <= i2 < 320 | 0
			comp00
		2- for 0 <= i3 < 320 | 0 | P
			comp01

<Schedule pruned>
parallelization unrolling: .*P\(\{(C[0-9],)*C0(,C[0-9])*\},L2\)U.*|.*P\(\{(C[0-9],)*C1(,C[0-9])*\},L2\)U.*
if

-----------
Matrix Transform 3x3 {comp00, } [1, 0, 0, 0, 1, 0, 0, 0, 1]
Matrix Transform 3x3 {comp01, } [1, 0, 0, 0, 1, 0, 0, 0, 1]
Parallelize L2 { comp01, }
Unrolling L2 8 { comp00, }
0- for 0 <= i0 < 64 | 0
	1- for 0 <= i1 < 64 | 0
		2- for 0 <= i2 < 320 | 0
			comp00
		2- for 0 <= i3 < 320 | 0 | P
			comp01

<Schedule pruned>
parallelization unrolling: .*P\(\{(C[0-9],)*C0(,C[0-9])*\},L2\)U.*|.*P\(\{(C[0-9],)*C1(,C[0-9])*\},L2\)U.*
if

-----------
Matrix Transform 3x3 {comp00, } [1, 0, 0, 0, 1, 0, 0, 0, 1]
Matrix Transform 3x3 {comp01, } [1, 0, 0, 0, 1, 0, 0, 0, 1]
Parallelize L2 { comp01, }
Unrolling L2 16 { comp00, }
0- for 0 <= i0 < 64 | 0
	1- for 0 <= i1 < 64 | 0
		2- for 0 <= i2 < 320 | 0
			comp00
		2- for 0 <= i3 < 320 | 0 | P
			comp01

<Schedule pruned>
parallelization unrolling: .*P\(\{(C[0-9],)*C0(,C[0-9])*\},L2\)U.*|.*P\(\{(C[0-9],)*C1(,C[0-9])*\},L2\)U.*
parallelization tiling: .*P\(\{(C[0-9],)*C0(,C[0-9])*\},L2\)T2\(\{(C[0-9],)*C0(,C[0-9])*\},L0,L1.*|.*P\(\{(C[0-9],)*C1(,C[0-9])*\},L2\)T2\(\{(C[0-9],)*C1(,C[0-9])*\},L0,L1.*
else
transform_ast

-----------
Matrix Transform 3x3 {comp00, } [1, 0, 0, 0, 1, 0, 0, 0, 1]
Matrix Transform 3x3 {comp01, } [1, 0, 0, 0, 1, 0, 0, 0, 1]
Parallelize L1 { comp00, comp01, }
Tiling L0 32 L1 32 { comp00, comp01, }
0- for 0 <= i0_outer < 2 | 0
	1- for 0 <= i1_outer < 2 | 0 | P
		2- for 0 <= i0_inner < 32 | 0
			3- for 0 <= i1_inner < 32 | 0
				4- for 0 <= i2 < 320 | 0
					comp00
				4- for 0 <= i3 < 320 | 0
					comp01

<legal>

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf02.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf02"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf02 = _halide_buffer_get_host(buf02.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input03_b2[float64 * 320 * 64 * 64]
  allocate _input01_b1[float64 * 320]
  allocate _icomp00_b0[float64 * 64 * 64]
  allocate _comp01_b4[float64 * 320 * 64 * 64]
  allocate _comp00_b3[float64 * 320 * 64 * 64]
  for (c1, 0, 2) {
    parallel (c3, 0, 2) {
      for (c5, 0, 32) {
        for (c7, 0, 32) {
          for (c9, 0, 320) {
            buf00[(((c3*32) + c7) + int32((int64(((c1*32) + c5))*(int64)64)))] = ((1.000000 - (buf01[c9]*1.260000))*buf00[(((c3*32) + c7) + int32((int64(((c1*32) + c5))*(int64)64)))])
          }
          for (c9, 0, 320) {
            buf02[((c9 + int32((int64(((c3*32) + c7))*(int64)320))) + int32((int64(((c1*32) + c5))*(int64)20480)))] = (buf00[(((c3*32) + c7) + int32((int64(((c1*32) + c5))*(int64)64)))] + buf03[((c9 + int32((int64(((c3*32) + c7))*(int64)320))) + int32((int64(((c1*32) + c5))*(int64)20480)))])
          }
        }
      }
    }
  }
}

<legal>
Schedule number 9
Evaluation : 1.372810
Number of measurements : 3
===================================

parallelization unrolling: .*P\(\{(C[0-9],)*C0(,C[0-9])*\},L2\)U.*|.*P\(\{(C[0-9],)*C1(,C[0-9])*\},L2\)U.*
parallelization tiling: .*P\(\{(C[0-9],)*C0(,C[0-9])*\},L2\)T2\(\{(C[0-9],)*C0(,C[0-9])*\},L0,L1.*|.*P\(\{(C[0-9],)*C1(,C[0-9])*\},L2\)T2\(\{(C[0-9],)*C1(,C[0-9])*\},L0,L1.*
else
transform_ast

-----------
Matrix Transform 3x3 {comp00, } [1, 0, 0, 0, 1, 0, 0, 0, 1]
Matrix Transform 3x3 {comp01, } [1, 0, 0, 0, 1, 0, 0, 0, 1]
Parallelize L1 { comp00, comp01, }
Unrolling L2 4 { comp00, }
0- for 0 <= i0 < 64 | 0
	1- for 0 <= i1 < 64 | 0 | P
		2- for 0 <= i2_outer < 80 | 0
			3- for 0 <= i2_inner < 4 | 1
				comp00
		2- for 0 <= i3 < 320 | 0
			comp01

<legal>

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf02.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf02"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf02 = _halide_buffer_get_host(buf02.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input03_b2[float64 * 320 * 64 * 64]
  allocate _input01_b1[float64 * 320]
  allocate _icomp00_b0[float64 * 64 * 64]
  allocate _comp01_b4[float64 * 320 * 64 * 64]
  allocate _comp00_b3[float64 * 320 * 64 * 64]
  for (c1, 0, 64) {
    parallel (c3, 0, 64) {
      for (c5, 0, 80) {
        unrolled (c7, 0, 4) {
          buf00[(c3 + int32((int64(c1)*(int64)64)))] = ((1.000000 - (buf01[((c5*4) + c7)]*1.260000))*buf00[(c3 + int32((int64(c1)*(int64)64)))])
        }
      }
      for (c5, 0, 320) {
        buf02[((c5 + int32((int64(c3)*(int64)320))) + int32((int64(c1)*(int64)20480)))] = (buf00[(c3 + int32((int64(c1)*(int64)64)))] + buf03[((c5 + int32((int64(c3)*(int64)320))) + int32((int64(c1)*(int64)20480)))])
      }
    }
  }
}

<legal>
Schedule number 10
Evaluation : 2.243130
Number of measurements : 3
===================================

parallelization unrolling: .*P\(\{(C[0-9],)*C0(,C[0-9])*\},L2\)U.*|.*P\(\{(C[0-9],)*C1(,C[0-9])*\},L2\)U.*
parallelization tiling: .*P\(\{(C[0-9],)*C0(,C[0-9])*\},L2\)T2\(\{(C[0-9],)*C0(,C[0-9])*\},L0,L1.*|.*P\(\{(C[0-9],)*C1(,C[0-9])*\},L2\)T2\(\{(C[0-9],)*C1(,C[0-9])*\},L0,L1.*
else
transform_ast

-----------
Matrix Transform 3x3 {comp00, } [1, 0, 0, 0, 1, 0, 0, 0, 1]
Matrix Transform 3x3 {comp01, } [1, 0, 0, 0, 1, 0, 0, 0, 1]
Parallelize L1 { comp00, comp01, }
Unrolling L2 8 { comp00, }
0- for 0 <= i0 < 64 | 0
	1- for 0 <= i1 < 64 | 0 | P
		2- for 0 <= i2_outer < 40 | 0
			3- for 0 <= i2_inner < 8 | 1
				comp00
		2- for 0 <= i3 < 320 | 0
			comp01

<legal>

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf02.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf02"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf02 = _halide_buffer_get_host(buf02.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input03_b2[float64 * 320 * 64 * 64]
  allocate _input01_b1[float64 * 320]
  allocate _icomp00_b0[float64 * 64 * 64]
  allocate _comp01_b4[float64 * 320 * 64 * 64]
  allocate _comp00_b3[float64 * 320 * 64 * 64]
  for (c1, 0, 64) {
    parallel (c3, 0, 64) {
      for (c5, 0, 40) {
        unrolled (c7, 0, 8) {
          buf00[(c3 + int32((int64(c1)*(int64)64)))] = ((1.000000 - (buf01[((c5*8) + c7)]*1.260000))*buf00[(c3 + int32((int64(c1)*(int64)64)))])
        }
      }
      for (c5, 0, 320) {
        buf02[((c5 + int32((int64(c3)*(int64)320))) + int32((int64(c1)*(int64)20480)))] = (buf00[(c3 + int32((int64(c1)*(int64)64)))] + buf03[((c5 + int32((int64(c3)*(int64)320))) + int32((int64(c1)*(int64)20480)))])
      }
    }
  }
}

<legal>
Schedule number 11
Evaluation : 4.089880
Number of measurements : 3
===================================

parallelization unrolling: .*P\(\{(C[0-9],)*C0(,C[0-9])*\},L2\)U.*|.*P\(\{(C[0-9],)*C1(,C[0-9])*\},L2\)U.*
parallelization tiling: .*P\(\{(C[0-9],)*C0(,C[0-9])*\},L2\)T2\(\{(C[0-9],)*C0(,C[0-9])*\},L0,L1.*|.*P\(\{(C[0-9],)*C1(,C[0-9])*\},L2\)T2\(\{(C[0-9],)*C1(,C[0-9])*\},L0,L1.*
else
transform_ast

-----------
Matrix Transform 3x3 {comp00, } [1, 0, 0, 0, 1, 0, 0, 0, 1]
Matrix Transform 3x3 {comp01, } [1, 0, 0, 0, 1, 0, 0, 0, 1]
Parallelize L1 { comp00, comp01, }
Unrolling L2 16 { comp00, }
0- for 0 <= i0 < 64 | 0
	1- for 0 <= i1 < 64 | 0 | P
		2- for 0 <= i2_outer < 20 | 0
			3- for 0 <= i2_inner < 16 | 1
				comp00
		2- for 0 <= i3 < 320 | 0
			comp01

<legal>

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf02.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf02"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf02 = _halide_buffer_get_host(buf02.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input03_b2[float64 * 320 * 64 * 64]
  allocate _input01_b1[float64 * 320]
  allocate _icomp00_b0[float64 * 64 * 64]
  allocate _comp01_b4[float64 * 320 * 64 * 64]
  allocate _comp00_b3[float64 * 320 * 64 * 64]
  for (c1, 0, 64) {
    parallel (c3, 0, 64) {
      for (c5, 0, 20) {
        unrolled (c7, 0, 16) {
          buf00[(c3 + int32((int64(c1)*(int64)64)))] = ((1.000000 - (buf01[((c5*16) + c7)]*1.260000))*buf00[(c3 + int32((int64(c1)*(int64)64)))])
        }
      }
      for (c5, 0, 320) {
        buf02[((c5 + int32((int64(c3)*(int64)320))) + int32((int64(c1)*(int64)20480)))] = (buf00[(c3 + int32((int64(c1)*(int64)64)))] + buf03[((c5 + int32((int64(c3)*(int64)320))) + int32((int64(c1)*(int64)20480)))])
      }
    }
  }
}

<legal>
Schedule number 12
Evaluation : 1.457490
Number of measurements : 3
===================================

parallelization unrolling: .*P\(\{(C[0-9],)*C0(,C[0-9])*\},L2\)U.*|.*P\(\{(C[0-9],)*C1(,C[0-9])*\},L2\)U.*
parallelization tiling: .*P\(\{(C[0-9],)*C0(,C[0-9])*\},L2\)T2\(\{(C[0-9],)*C0(,C[0-9])*\},L0,L1.*|.*P\(\{(C[0-9],)*C1(,C[0-9])*\},L2\)T2\(\{(C[0-9],)*C1(,C[0-9])*\},L0,L1.*
else
transform_ast

-----------
Matrix Transform 3x3 {comp00, } [1, 0, 0, 0, 1, 0, 0, 0, 1]
Matrix Transform 3x3 {comp01, } [1, 0, 0, 0, 1, 0, 0, 0, 1]
Parallelize L1 { comp00, comp01, }
Unrolling L2 4 { comp01, }
0- for 0 <= i0 < 64 | 0
	1- for 0 <= i1 < 64 | 0 | P
		2- for 0 <= i2 < 320 | 0
			comp00
		2- for 0 <= i3_outer < 80 | 0
			3- for 0 <= i3_inner < 4 | 1
				comp01

<legal>

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf02.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf02"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf02 = _halide_buffer_get_host(buf02.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input03_b2[float64 * 320 * 64 * 64]
  allocate _input01_b1[float64 * 320]
  allocate _icomp00_b0[float64 * 64 * 64]
  allocate _comp01_b4[float64 * 320 * 64 * 64]
  allocate _comp00_b3[float64 * 320 * 64 * 64]
  for (c1, 0, 64) {
    parallel (c3, 0, 64) {
      for (c5, 0, 320) {
        buf00[(c3 + int32((int64(c1)*(int64)64)))] = ((1.000000 - (buf01[c5]*1.260000))*buf00[(c3 + int32((int64(c1)*(int64)64)))])
      }
      for (c5, 0, 80) {
        unrolled (c7, 0, 4) {
          buf02[((((c5*4) + c7) + int32((int64(c3)*(int64)320))) + int32((int64(c1)*(int64)20480)))] = (buf00[(c3 + int32((int64(c1)*(int64)64)))] + buf03[((((c5*4) + c7) + int32((int64(c3)*(int64)320))) + int32((int64(c1)*(int64)20480)))])
        }
      }
    }
  }
}

<legal>
Schedule number 13
Evaluation : 1.363930
Number of measurements : 3
===================================

parallelization unrolling: .*P\(\{(C[0-9],)*C0(,C[0-9])*\},L2\)U.*|.*P\(\{(C[0-9],)*C1(,C[0-9])*\},L2\)U.*
parallelization tiling: .*P\(\{(C[0-9],)*C0(,C[0-9])*\},L2\)T2\(\{(C[0-9],)*C0(,C[0-9])*\},L0,L1.*|.*P\(\{(C[0-9],)*C1(,C[0-9])*\},L2\)T2\(\{(C[0-9],)*C1(,C[0-9])*\},L0,L1.*
else
transform_ast

-----------
Matrix Transform 3x3 {comp00, } [1, 0, 0, 0, 1, 0, 0, 0, 1]
Matrix Transform 3x3 {comp01, } [1, 0, 0, 0, 1, 0, 0, 0, 1]
Parallelize L1 { comp00, comp01, }
Unrolling L2 8 { comp01, }
0- for 0 <= i0 < 64 | 0
	1- for 0 <= i1 < 64 | 0 | P
		2- for 0 <= i2 < 320 | 0
			comp00
		2- for 0 <= i3_outer < 40 | 0
			3- for 0 <= i3_inner < 8 | 1
				comp01

<legal>

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf02.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf02"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf02 = _halide_buffer_get_host(buf02.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input03_b2[float64 * 320 * 64 * 64]
  allocate _input01_b1[float64 * 320]
  allocate _icomp00_b0[float64 * 64 * 64]
  allocate _comp01_b4[float64 * 320 * 64 * 64]
  allocate _comp00_b3[float64 * 320 * 64 * 64]
  for (c1, 0, 64) {
    parallel (c3, 0, 64) {
      for (c5, 0, 320) {
        buf00[(c3 + int32((int64(c1)*(int64)64)))] = ((1.000000 - (buf01[c5]*1.260000))*buf00[(c3 + int32((int64(c1)*(int64)64)))])
      }
      for (c5, 0, 40) {
        unrolled (c7, 0, 8) {
          buf02[((((c5*8) + c7) + int32((int64(c3)*(int64)320))) + int32((int64(c1)*(int64)20480)))] = (buf00[(c3 + int32((int64(c1)*(int64)64)))] + buf03[((((c5*8) + c7) + int32((int64(c3)*(int64)320))) + int32((int64(c1)*(int64)20480)))])
        }
      }
    }
  }
}

<legal>
Schedule number 14
Evaluation : 1.925800
Number of measurements : 3
===================================

parallelization unrolling: .*P\(\{(C[0-9],)*C0(,C[0-9])*\},L2\)U.*|.*P\(\{(C[0-9],)*C1(,C[0-9])*\},L2\)U.*
parallelization tiling: .*P\(\{(C[0-9],)*C0(,C[0-9])*\},L2\)T2\(\{(C[0-9],)*C0(,C[0-9])*\},L0,L1.*|.*P\(\{(C[0-9],)*C1(,C[0-9])*\},L2\)T2\(\{(C[0-9],)*C1(,C[0-9])*\},L0,L1.*
else
transform_ast

-----------
Matrix Transform 3x3 {comp00, } [1, 0, 0, 0, 1, 0, 0, 0, 1]
Matrix Transform 3x3 {comp01, } [1, 0, 0, 0, 1, 0, 0, 0, 1]
Parallelize L1 { comp00, comp01, }
Unrolling L2 16 { comp01, }
0- for 0 <= i0 < 64 | 0
	1- for 0 <= i1 < 64 | 0 | P
		2- for 0 <= i2 < 320 | 0
			comp00
		2- for 0 <= i3_outer < 20 | 0
			3- for 0 <= i3_inner < 16 | 1
				comp01

<legal>

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf02.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf02"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf02 = _halide_buffer_get_host(buf02.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input03_b2[float64 * 320 * 64 * 64]
  allocate _input01_b1[float64 * 320]
  allocate _icomp00_b0[float64 * 64 * 64]
  allocate _comp01_b4[float64 * 320 * 64 * 64]
  allocate _comp00_b3[float64 * 320 * 64 * 64]
  for (c1, 0, 64) {
    parallel (c3, 0, 64) {
      for (c5, 0, 320) {
        buf00[(c3 + int32((int64(c1)*(int64)64)))] = ((1.000000 - (buf01[c5]*1.260000))*buf00[(c3 + int32((int64(c1)*(int64)64)))])
      }
      for (c5, 0, 20) {
        unrolled (c7, 0, 16) {
          buf02[((((c5*16) + c7) + int32((int64(c3)*(int64)320))) + int32((int64(c1)*(int64)20480)))] = (buf00[(c3 + int32((int64(c1)*(int64)64)))] + buf03[((((c5*16) + c7) + int32((int64(c3)*(int64)320))) + int32((int64(c1)*(int64)20480)))])
        }
      }
    }
  }
}

<legal>
Schedule number 15
Evaluation : 1.323390
Number of measurements : 3
===================================

parallelization unrolling: .*P\(\{(C[0-9],)*C0(,C[0-9])*\},L2\)U.*|.*P\(\{(C[0-9],)*C1(,C[0-9])*\},L2\)U.*
parallelization tiling: .*P\(\{(C[0-9],)*C0(,C[0-9])*\},L2\)T2\(\{(C[0-9],)*C0(,C[0-9])*\},L0,L1.*|.*P\(\{(C[0-9],)*C1(,C[0-9])*\},L2\)T2\(\{(C[0-9],)*C1(,C[0-9])*\},L0,L1.*
else
transform_ast

-----------
Matrix Transform 3x3 {comp00, } [1, 0, 0, 0, 1, 0, 0, 0, 1]
Matrix Transform 3x3 {comp01, } [1, 0, 0, 0, 1, 0, 0, 0, 1]
Parallelize L1 { comp00, comp01, }
Tiling L0 32 L1 32 { comp00, comp01, }
Unrolling L4 4 { comp00, }
0- for 0 <= i0_outer < 2 | 0
	1- for 0 <= i1_outer < 2 | 0 | P
		2- for 0 <= i0_inner < 32 | 0
			3- for 0 <= i1_inner < 32 | 0
				4- for 0 <= i2_outer < 80 | 0
					5- for 0 <= i2_inner < 4 | 1
						comp00
				4- for 0 <= i3 < 320 | 0
					comp01

<legal>

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf02.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf02"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf02 = _halide_buffer_get_host(buf02.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input03_b2[float64 * 320 * 64 * 64]
  allocate _input01_b1[float64 * 320]
  allocate _icomp00_b0[float64 * 64 * 64]
  allocate _comp01_b4[float64 * 320 * 64 * 64]
  allocate _comp00_b3[float64 * 320 * 64 * 64]
  for (c1, 0, 2) {
    parallel (c3, 0, 2) {
      for (c5, 0, 32) {
        for (c7, 0, 32) {
          for (c9, 0, 80) {
            unrolled (c11, 0, 4) {
              buf00[(((c3*32) + c7) + int32((int64(((c1*32) + c5))*(int64)64)))] = ((1.000000 - (buf01[((c9*4) + c11)]*1.260000))*buf00[(((c3*32) + c7) + int32((int64(((c1*32) + c5))*(int64)64)))])
            }
          }
          for (c9, 0, 320) {
            buf02[((c9 + int32((int64(((c3*32) + c7))*(int64)320))) + int32((int64(((c1*32) + c5))*(int64)20480)))] = (buf00[(((c3*32) + c7) + int32((int64(((c1*32) + c5))*(int64)64)))] + buf03[((c9 + int32((int64(((c3*32) + c7))*(int64)320))) + int32((int64(((c1*32) + c5))*(int64)20480)))])
          }
        }
      }
    }
  }
}

<legal>
Schedule number 16
Evaluation : 1.240700
Number of measurements : 3
===================================

parallelization unrolling: .*P\(\{(C[0-9],)*C0(,C[0-9])*\},L2\)U.*|.*P\(\{(C[0-9],)*C1(,C[0-9])*\},L2\)U.*
parallelization tiling: .*P\(\{(C[0-9],)*C0(,C[0-9])*\},L2\)T2\(\{(C[0-9],)*C0(,C[0-9])*\},L0,L1.*|.*P\(\{(C[0-9],)*C1(,C[0-9])*\},L2\)T2\(\{(C[0-9],)*C1(,C[0-9])*\},L0,L1.*
else
transform_ast

-----------
Matrix Transform 3x3 {comp00, } [1, 0, 0, 0, 1, 0, 0, 0, 1]
Matrix Transform 3x3 {comp01, } [1, 0, 0, 0, 1, 0, 0, 0, 1]
Parallelize L1 { comp00, comp01, }
Tiling L0 32 L1 32 { comp00, comp01, }
Unrolling L4 8 { comp00, }
0- for 0 <= i0_outer < 2 | 0
	1- for 0 <= i1_outer < 2 | 0 | P
		2- for 0 <= i0_inner < 32 | 0
			3- for 0 <= i1_inner < 32 | 0
				4- for 0 <= i2_outer < 40 | 0
					5- for 0 <= i2_inner < 8 | 1
						comp00
				4- for 0 <= i3 < 320 | 0
					comp01

<legal>

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf02.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf02"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf02 = _halide_buffer_get_host(buf02.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input03_b2[float64 * 320 * 64 * 64]
  allocate _input01_b1[float64 * 320]
  allocate _icomp00_b0[float64 * 64 * 64]
  allocate _comp01_b4[float64 * 320 * 64 * 64]
  allocate _comp00_b3[float64 * 320 * 64 * 64]
  for (c1, 0, 2) {
    parallel (c3, 0, 2) {
      for (c5, 0, 32) {
        for (c7, 0, 32) {
          for (c9, 0, 40) {
            unrolled (c11, 0, 8) {
              buf00[(((c3*32) + c7) + int32((int64(((c1*32) + c5))*(int64)64)))] = ((1.000000 - (buf01[((c9*8) + c11)]*1.260000))*buf00[(((c3*32) + c7) + int32((int64(((c1*32) + c5))*(int64)64)))])
            }
          }
          for (c9, 0, 320) {
            buf02[((c9 + int32((int64(((c3*32) + c7))*(int64)320))) + int32((int64(((c1*32) + c5))*(int64)20480)))] = (buf00[(((c3*32) + c7) + int32((int64(((c1*32) + c5))*(int64)64)))] + buf03[((c9 + int32((int64(((c3*32) + c7))*(int64)320))) + int32((int64(((c1*32) + c5))*(int64)20480)))])
          }
        }
      }
    }
  }
}

<legal>
Schedule number 17
Evaluation : 1.442270
Number of measurements : 3
===================================

parallelization unrolling: .*P\(\{(C[0-9],)*C0(,C[0-9])*\},L2\)U.*|.*P\(\{(C[0-9],)*C1(,C[0-9])*\},L2\)U.*
parallelization tiling: .*P\(\{(C[0-9],)*C0(,C[0-9])*\},L2\)T2\(\{(C[0-9],)*C0(,C[0-9])*\},L0,L1.*|.*P\(\{(C[0-9],)*C1(,C[0-9])*\},L2\)T2\(\{(C[0-9],)*C1(,C[0-9])*\},L0,L1.*
else
transform_ast

-----------
Matrix Transform 3x3 {comp00, } [1, 0, 0, 0, 1, 0, 0, 0, 1]
Matrix Transform 3x3 {comp01, } [1, 0, 0, 0, 1, 0, 0, 0, 1]
Parallelize L1 { comp00, comp01, }
Tiling L0 32 L1 32 { comp00, comp01, }
Unrolling L4 16 { comp00, }
0- for 0 <= i0_outer < 2 | 0
	1- for 0 <= i1_outer < 2 | 0 | P
		2- for 0 <= i0_inner < 32 | 0
			3- for 0 <= i1_inner < 32 | 0
				4- for 0 <= i2_outer < 20 | 0
					5- for 0 <= i2_inner < 16 | 1
						comp00
				4- for 0 <= i3 < 320 | 0
					comp01

<legal>

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf02.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf02"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf02 = _halide_buffer_get_host(buf02.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input03_b2[float64 * 320 * 64 * 64]
  allocate _input01_b1[float64 * 320]
  allocate _icomp00_b0[float64 * 64 * 64]
  allocate _comp01_b4[float64 * 320 * 64 * 64]
  allocate _comp00_b3[float64 * 320 * 64 * 64]
  for (c1, 0, 2) {
    parallel (c3, 0, 2) {
      for (c5, 0, 32) {
        for (c7, 0, 32) {
          for (c9, 0, 20) {
            unrolled (c11, 0, 16) {
              buf00[(((c3*32) + c7) + int32((int64(((c1*32) + c5))*(int64)64)))] = ((1.000000 - (buf01[((c9*16) + c11)]*1.260000))*buf00[(((c3*32) + c7) + int32((int64(((c1*32) + c5))*(int64)64)))])
            }
          }
          for (c9, 0, 320) {
            buf02[((c9 + int32((int64(((c3*32) + c7))*(int64)320))) + int32((int64(((c1*32) + c5))*(int64)20480)))] = (buf00[(((c3*32) + c7) + int32((int64(((c1*32) + c5))*(int64)64)))] + buf03[((c9 + int32((int64(((c3*32) + c7))*(int64)320))) + int32((int64(((c1*32) + c5))*(int64)20480)))])
          }
        }
      }
    }
  }
}

<legal>
Schedule number 18
Evaluation : 1.434070
Number of measurements : 3
===================================

parallelization unrolling: .*P\(\{(C[0-9],)*C0(,C[0-9])*\},L2\)U.*|.*P\(\{(C[0-9],)*C1(,C[0-9])*\},L2\)U.*
parallelization tiling: .*P\(\{(C[0-9],)*C0(,C[0-9])*\},L2\)T2\(\{(C[0-9],)*C0(,C[0-9])*\},L0,L1.*|.*P\(\{(C[0-9],)*C1(,C[0-9])*\},L2\)T2\(\{(C[0-9],)*C1(,C[0-9])*\},L0,L1.*
else
transform_ast

-----------
Matrix Transform 3x3 {comp00, } [1, 0, 0, 0, 1, 0, 0, 0, 1]
Matrix Transform 3x3 {comp01, } [1, 0, 0, 0, 1, 0, 0, 0, 1]
Parallelize L1 { comp00, comp01, }
Tiling L0 32 L1 32 { comp00, comp01, }
Unrolling L4 4 { comp01, }
0- for 0 <= i0_outer < 2 | 0
	1- for 0 <= i1_outer < 2 | 0 | P
		2- for 0 <= i0_inner < 32 | 0
			3- for 0 <= i1_inner < 32 | 0
				4- for 0 <= i2 < 320 | 0
					comp00
				4- for 0 <= i3_outer < 80 | 0
					5- for 0 <= i3_inner < 4 | 1
						comp01

<legal>

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf02.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf02"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf02 = _halide_buffer_get_host(buf02.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input03_b2[float64 * 320 * 64 * 64]
  allocate _input01_b1[float64 * 320]
  allocate _icomp00_b0[float64 * 64 * 64]
  allocate _comp01_b4[float64 * 320 * 64 * 64]
  allocate _comp00_b3[float64 * 320 * 64 * 64]
  for (c1, 0, 2) {
    parallel (c3, 0, 2) {
      for (c5, 0, 32) {
        for (c7, 0, 32) {
          for (c9, 0, 320) {
            buf00[(((c3*32) + c7) + int32((int64(((c1*32) + c5))*(int64)64)))] = ((1.000000 - (buf01[c9]*1.260000))*buf00[(((c3*32) + c7) + int32((int64(((c1*32) + c5))*(int64)64)))])
          }
          for (c9, 0, 80) {
            unrolled (c11, 0, 4) {
              buf02[((((c9*4) + c11) + int32((int64(((c3*32) + c7))*(int64)320))) + int32((int64(((c1*32) + c5))*(int64)20480)))] = (buf00[(((c3*32) + c7) + int32((int64(((c1*32) + c5))*(int64)64)))] + buf03[((((c9*4) + c11) + int32((int64(((c3*32) + c7))*(int64)320))) + int32((int64(((c1*32) + c5))*(int64)20480)))])
            }
          }
        }
      }
    }
  }
}

<legal>
Schedule number 19
Evaluation : 1.462780
Number of measurements : 3
===================================

parallelization unrolling: .*P\(\{(C[0-9],)*C0(,C[0-9])*\},L2\)U.*|.*P\(\{(C[0-9],)*C1(,C[0-9])*\},L2\)U.*
parallelization tiling: .*P\(\{(C[0-9],)*C0(,C[0-9])*\},L2\)T2\(\{(C[0-9],)*C0(,C[0-9])*\},L0,L1.*|.*P\(\{(C[0-9],)*C1(,C[0-9])*\},L2\)T2\(\{(C[0-9],)*C1(,C[0-9])*\},L0,L1.*
else
transform_ast

-----------
Matrix Transform 3x3 {comp00, } [1, 0, 0, 0, 1, 0, 0, 0, 1]
Matrix Transform 3x3 {comp01, } [1, 0, 0, 0, 1, 0, 0, 0, 1]
Parallelize L1 { comp00, comp01, }
Tiling L0 32 L1 32 { comp00, comp01, }
Unrolling L4 8 { comp01, }
0- for 0 <= i0_outer < 2 | 0
	1- for 0 <= i1_outer < 2 | 0 | P
		2- for 0 <= i0_inner < 32 | 0
			3- for 0 <= i1_inner < 32 | 0
				4- for 0 <= i2 < 320 | 0
					comp00
				4- for 0 <= i3_outer < 40 | 0
					5- for 0 <= i3_inner < 8 | 1
						comp01

<legal>

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf02.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf02"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf02 = _halide_buffer_get_host(buf02.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input03_b2[float64 * 320 * 64 * 64]
  allocate _input01_b1[float64 * 320]
  allocate _icomp00_b0[float64 * 64 * 64]
  allocate _comp01_b4[float64 * 320 * 64 * 64]
  allocate _comp00_b3[float64 * 320 * 64 * 64]
  for (c1, 0, 2) {
    parallel (c3, 0, 2) {
      for (c5, 0, 32) {
        for (c7, 0, 32) {
          for (c9, 0, 320) {
            buf00[(((c3*32) + c7) + int32((int64(((c1*32) + c5))*(int64)64)))] = ((1.000000 - (buf01[c9]*1.260000))*buf00[(((c3*32) + c7) + int32((int64(((c1*32) + c5))*(int64)64)))])
          }
          for (c9, 0, 40) {
            unrolled (c11, 0, 8) {
              buf02[((((c9*8) + c11) + int32((int64(((c3*32) + c7))*(int64)320))) + int32((int64(((c1*32) + c5))*(int64)20480)))] = (buf00[(((c3*32) + c7) + int32((int64(((c1*32) + c5))*(int64)64)))] + buf03[((((c9*8) + c11) + int32((int64(((c3*32) + c7))*(int64)320))) + int32((int64(((c1*32) + c5))*(int64)20480)))])
            }
          }
        }
      }
    }
  }
}

<legal>
Schedule number 20
Evaluation : 1.448600
Number of measurements : 3
===================================

parallelization unrolling: .*P\(\{(C[0-9],)*C0(,C[0-9])*\},L2\)U.*|.*P\(\{(C[0-9],)*C1(,C[0-9])*\},L2\)U.*
parallelization tiling: .*P\(\{(C[0-9],)*C0(,C[0-9])*\},L2\)T2\(\{(C[0-9],)*C0(,C[0-9])*\},L0,L1.*|.*P\(\{(C[0-9],)*C1(,C[0-9])*\},L2\)T2\(\{(C[0-9],)*C1(,C[0-9])*\},L0,L1.*
else
transform_ast

-----------
Matrix Transform 3x3 {comp00, } [1, 0, 0, 0, 1, 0, 0, 0, 1]
Matrix Transform 3x3 {comp01, } [1, 0, 0, 0, 1, 0, 0, 0, 1]
Parallelize L1 { comp00, comp01, }
Tiling L0 32 L1 32 { comp00, comp01, }
Unrolling L4 16 { comp01, }
0- for 0 <= i0_outer < 2 | 0
	1- for 0 <= i1_outer < 2 | 0 | P
		2- for 0 <= i0_inner < 32 | 0
			3- for 0 <= i1_inner < 32 | 0
				4- for 0 <= i2 < 320 | 0
					comp00
				4- for 0 <= i3_outer < 20 | 0
					5- for 0 <= i3_inner < 16 | 1
						comp01

<legal>

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf02.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf02"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf02 = _halide_buffer_get_host(buf02.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input03_b2[float64 * 320 * 64 * 64]
  allocate _input01_b1[float64 * 320]
  allocate _icomp00_b0[float64 * 64 * 64]
  allocate _comp01_b4[float64 * 320 * 64 * 64]
  allocate _comp00_b3[float64 * 320 * 64 * 64]
  for (c1, 0, 2) {
    parallel (c3, 0, 2) {
      for (c5, 0, 32) {
        for (c7, 0, 32) {
          for (c9, 0, 320) {
            buf00[(((c3*32) + c7) + int32((int64(((c1*32) + c5))*(int64)64)))] = ((1.000000 - (buf01[c9]*1.260000))*buf00[(((c3*32) + c7) + int32((int64(((c1*32) + c5))*(int64)64)))])
          }
          for (c9, 0, 20) {
            unrolled (c11, 0, 16) {
              buf02[((((c9*16) + c11) + int32((int64(((c3*32) + c7))*(int64)320))) + int32((int64(((c1*32) + c5))*(int64)20480)))] = (buf00[(((c3*32) + c7) + int32((int64(((c1*32) + c5))*(int64)64)))] + buf03[((((c9*16) + c11) + int32((int64(((c3*32) + c7))*(int64)320))) + int32((int64(((c1*32) + c5))*(int64)20480)))])
            }
          }
        }
      }
    }
  }
}

<legal>
Schedule number 21
Evaluation : 1.487910
Number of measurements : 3
===================================

parallelization unrolling: .*P\(\{(C[0-9],)*C0(,C[0-9])*\},L2\)U.*|.*P\(\{(C[0-9],)*C1(,C[0-9])*\},L2\)U.*
parallelization tiling: .*P\(\{(C[0-9],)*C0(,C[0-9])*\},L2\)T2\(\{(C[0-9],)*C0(,C[0-9])*\},L0,L1.*|.*P\(\{(C[0-9],)*C1(,C[0-9])*\},L2\)T2\(\{(C[0-9],)*C1(,C[0-9])*\},L0,L1.*
else
transform_ast

-----------
Matrix Transform 3x3 {comp00, } [1, 0, 0, 0, 1, 0, 0, 0, 1]
Matrix Transform 3x3 {comp01, } [1, 0, 0, 0, 1, 0, 0, 0, 1]
Parallelize L1 { comp00, comp01, }
Tiling L0 32 L1 32 { comp00, comp01, }
Unrolling L4 4 { comp00, }
Unrolling L4 4 { comp01, }
0- for 0 <= i0_outer < 2 | 0
	1- for 0 <= i1_outer < 2 | 0 | P
		2- for 0 <= i0_inner < 32 | 0
			3- for 0 <= i1_inner < 32 | 0
				4- for 0 <= i2_outer < 80 | 0
					5- for 0 <= i2_inner < 4 | 1
						comp00
				4- for 0 <= i3_outer < 80 | 0
					5- for 0 <= i3_inner < 4 | 1
						comp01

<legal>

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf02.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf02"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf02 = _halide_buffer_get_host(buf02.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input03_b2[float64 * 320 * 64 * 64]
  allocate _input01_b1[float64 * 320]
  allocate _icomp00_b0[float64 * 64 * 64]
  allocate _comp01_b4[float64 * 320 * 64 * 64]
  allocate _comp00_b3[float64 * 320 * 64 * 64]
  for (c1, 0, 2) {
    parallel (c3, 0, 2) {
      for (c5, 0, 32) {
        for (c7, 0, 32) {
          for (c9, 0, 80) {
            unrolled (c11, 0, 4) {
              buf00[(((c3*32) + c7) + int32((int64(((c1*32) + c5))*(int64)64)))] = ((1.000000 - (buf01[((c9*4) + c11)]*1.260000))*buf00[(((c3*32) + c7) + int32((int64(((c1*32) + c5))*(int64)64)))])
            }
          }
          for (c9, 0, 80) {
            unrolled (c11, 0, 4) {
              buf02[((((c9*4) + c11) + int32((int64(((c3*32) + c7))*(int64)320))) + int32((int64(((c1*32) + c5))*(int64)20480)))] = (buf00[(((c3*32) + c7) + int32((int64(((c1*32) + c5))*(int64)64)))] + buf03[((((c9*4) + c11) + int32((int64(((c3*32) + c7))*(int64)320))) + int32((int64(((c1*32) + c5))*(int64)20480)))])
            }
          }
        }
      }
    }
  }
}

<legal>
Schedule number 22
Evaluation : 1.320920
Number of measurements : 3
===================================

parallelization unrolling: .*P\(\{(C[0-9],)*C0(,C[0-9])*\},L2\)U.*|.*P\(\{(C[0-9],)*C1(,C[0-9])*\},L2\)U.*
parallelization tiling: .*P\(\{(C[0-9],)*C0(,C[0-9])*\},L2\)T2\(\{(C[0-9],)*C0(,C[0-9])*\},L0,L1.*|.*P\(\{(C[0-9],)*C1(,C[0-9])*\},L2\)T2\(\{(C[0-9],)*C1(,C[0-9])*\},L0,L1.*
else
transform_ast

-----------
Matrix Transform 3x3 {comp00, } [1, 0, 0, 0, 1, 0, 0, 0, 1]
Matrix Transform 3x3 {comp01, } [1, 0, 0, 0, 1, 0, 0, 0, 1]
Parallelize L1 { comp00, comp01, }
Tiling L0 32 L1 32 { comp00, comp01, }
Unrolling L4 4 { comp00, }
Unrolling L4 8 { comp01, }
0- for 0 <= i0_outer < 2 | 0
	1- for 0 <= i1_outer < 2 | 0 | P
		2- for 0 <= i0_inner < 32 | 0
			3- for 0 <= i1_inner < 32 | 0
				4- for 0 <= i2_outer < 80 | 0
					5- for 0 <= i2_inner < 4 | 1
						comp00
				4- for 0 <= i3_outer < 40 | 0
					5- for 0 <= i3_inner < 8 | 1
						comp01

<legal>

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf02.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf02"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf02 = _halide_buffer_get_host(buf02.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input03_b2[float64 * 320 * 64 * 64]
  allocate _input01_b1[float64 * 320]
  allocate _icomp00_b0[float64 * 64 * 64]
  allocate _comp01_b4[float64 * 320 * 64 * 64]
  allocate _comp00_b3[float64 * 320 * 64 * 64]
  for (c1, 0, 2) {
    parallel (c3, 0, 2) {
      for (c5, 0, 32) {
        for (c7, 0, 32) {
          for (c9, 0, 80) {
            unrolled (c11, 0, 4) {
              buf00[(((c3*32) + c7) + int32((int64(((c1*32) + c5))*(int64)64)))] = ((1.000000 - (buf01[((c9*4) + c11)]*1.260000))*buf00[(((c3*32) + c7) + int32((int64(((c1*32) + c5))*(int64)64)))])
            }
          }
          for (c9, 0, 40) {
            unrolled (c11, 0, 8) {
              buf02[((((c9*8) + c11) + int32((int64(((c3*32) + c7))*(int64)320))) + int32((int64(((c1*32) + c5))*(int64)20480)))] = (buf00[(((c3*32) + c7) + int32((int64(((c1*32) + c5))*(int64)64)))] + buf03[((((c9*8) + c11) + int32((int64(((c3*32) + c7))*(int64)320))) + int32((int64(((c1*32) + c5))*(int64)20480)))])
            }
          }
        }
      }
    }
  }
}

<legal>
Schedule number 23
Evaluation : 1.466210
Number of measurements : 3
===================================

parallelization unrolling: .*P\(\{(C[0-9],)*C0(,C[0-9])*\},L2\)U.*|.*P\(\{(C[0-9],)*C1(,C[0-9])*\},L2\)U.*
parallelization tiling: .*P\(\{(C[0-9],)*C0(,C[0-9])*\},L2\)T2\(\{(C[0-9],)*C0(,C[0-9])*\},L0,L1.*|.*P\(\{(C[0-9],)*C1(,C[0-9])*\},L2\)T2\(\{(C[0-9],)*C1(,C[0-9])*\},L0,L1.*
else
transform_ast

-----------
Matrix Transform 3x3 {comp00, } [1, 0, 0, 0, 1, 0, 0, 0, 1]
Matrix Transform 3x3 {comp01, } [1, 0, 0, 0, 1, 0, 0, 0, 1]
Parallelize L1 { comp00, comp01, }
Tiling L0 32 L1 32 { comp00, comp01, }
Unrolling L4 4 { comp00, }
Unrolling L4 16 { comp01, }
0- for 0 <= i0_outer < 2 | 0
	1- for 0 <= i1_outer < 2 | 0 | P
		2- for 0 <= i0_inner < 32 | 0
			3- for 0 <= i1_inner < 32 | 0
				4- for 0 <= i2_outer < 80 | 0
					5- for 0 <= i2_inner < 4 | 1
						comp00
				4- for 0 <= i3_outer < 20 | 0
					5- for 0 <= i3_inner < 16 | 1
						comp01

<legal>

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf02.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf02"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf02 = _halide_buffer_get_host(buf02.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input03_b2[float64 * 320 * 64 * 64]
  allocate _input01_b1[float64 * 320]
  allocate _icomp00_b0[float64 * 64 * 64]
  allocate _comp01_b4[float64 * 320 * 64 * 64]
  allocate _comp00_b3[float64 * 320 * 64 * 64]
  for (c1, 0, 2) {
    parallel (c3, 0, 2) {
      for (c5, 0, 32) {
        for (c7, 0, 32) {
          for (c9, 0, 80) {
            unrolled (c11, 0, 4) {
              buf00[(((c3*32) + c7) + int32((int64(((c1*32) + c5))*(int64)64)))] = ((1.000000 - (buf01[((c9*4) + c11)]*1.260000))*buf00[(((c3*32) + c7) + int32((int64(((c1*32) + c5))*(int64)64)))])
            }
          }
          for (c9, 0, 20) {
            unrolled (c11, 0, 16) {
              buf02[((((c9*16) + c11) + int32((int64(((c3*32) + c7))*(int64)320))) + int32((int64(((c1*32) + c5))*(int64)20480)))] = (buf00[(((c3*32) + c7) + int32((int64(((c1*32) + c5))*(int64)64)))] + buf03[((((c9*16) + c11) + int32((int64(((c3*32) + c7))*(int64)320))) + int32((int64(((c1*32) + c5))*(int64)20480)))])
            }
          }
        }
      }
    }
  }
}

<legal>
Schedule number 24
Evaluation : 1.329600
Number of measurements : 3
===================================


-----------
Matrix Transform 3x3 {comp00, } [1, 0, 0, 0, 1, 0, 0, 0, 1]
Matrix Transform 3x3 {comp01, } [1, 0, 0, 0, 1, 0, 0, 0, 1]
Matrix Transform 2x2 {comp00, comp01, } [1, 0, 0, -1]
Matrix Transform 3x3 {comp00, } [1, 0, 0, 0, 1, 0, 0, 0, -1]
0- for 0 <= i0 < 64 | 0
	1- for -63 <= i1 < 1 | 0
		2- for -319 <= i2 < 1 | 0
			comp00
		2- for 0 <= i3 < 320 | 0
			comp01
{ comp00[t10, t11, t12] -> comp00[0, 0, t146 = t10, 0, t147 = -t11, 0, t148 = -t12, 0] : 0 <= t10 <= 63 and 0 <= t11 <= 63 and 0 <= t12 <= 319 }{ comp01[t14, t15, t16] -> comp01[0, 0, t65 = t14, 0, t66 = -t15, 10, t67 = t16, 0] : 0 <= t14 <= 63 and 0 <= t15 <= 63 and 0 <= t16 <= 319 }
<illegal>

-----------
Matrix Transform 3x3 {comp00, } [1, 0, 0, 0, 1, 0, 0, 0, 1]
Matrix Transform 3x3 {comp01, } [1, 0, 0, 0, 1, 0, 0, 0, 1]
Matrix Transform 2x2 {comp00, comp01, } [1, 0, 0, -1]
Matrix Transform 3x3 {comp01, } [1, 0, 0, 0, 1, 0, 0, 0, -1]
0- for 0 <= i0 < 64 | 0
	1- for -63 <= i1 < 1 | 0
		2- for 0 <= i2 < 320 | 0
			comp00
		2- for -319 <= i3 < 1 | 0
			comp01
{ comp00[t10, t11, t12] -> comp00[0, 0, t62 = t10, 0, t63 = -t11, 0, t64 = t12, 0] : 0 <= t10 <= 63 and 0 <= t11 <= 63 and 0 <= t12 <= 319 }{ comp01[t14, t15, t16] -> comp01[0, 0, t153 = t14, 0, t154 = -t15, 10, t155 = -t16, 0] : 0 <= t14 <= 63 and 0 <= t15 <= 63 and 0 <= t16 <= 319 }
<legal>



input01:0 0 1 0 ,
icomp00:1 0 0 0 ,0 1 0 0 ,

icomp00:1 0 0 0 ,0 1 0 0 ,
input03:1 0 0 0 ,0 1 0 0 ,0 0 1 0 ,

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf02.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf02"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf02 = _halide_buffer_get_host(buf02.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input03_b2[float64 * 320 * 64 * 64]
  allocate _input01_b1[float64 * 320]
  allocate _icomp00_b0[float64 * 64 * 64]
  allocate _comp01_b4[float64 * 320 * 64 * 64]
  allocate _comp00_b3[float64 * 320 * 64 * 64]
  for (c1, 0, 64) {
    for (c3, -63, 64) {
      for (c5, 0, 320) {
        buf00[(int32((int64(c1)*(int64)64)) - c3)] = ((1.000000 - (buf01[c5]*1.260000))*buf00[(int32((int64(c1)*(int64)64)) - c3)])
      }
      for (c5, -319, 320) {
        buf02[((int32((int64((0 - c3))*(int64)320)) - c5) + int32((int64(c1)*(int64)20480)))] = (buf00[(int32((int64(c1)*(int64)64)) - c3)] + buf03[((int32((int64((0 - c3))*(int64)320)) - c5) + int32((int64(c1)*(int64)20480)))])
      }
    }
  }
}
{ comp00[t10, t11, t12] -> comp00[0, 0, t62 = t10, 0, t63 = -t11, 0, t64 = t12, 0] : 0 <= t10 <= 63 and 0 <= t11 <= 63 and 0 <= t12 <= 319 }{ comp01[t14, t15, t16] -> comp01[0, 0, t153 = t14, 0, t154 = -t15, 10, t155 = -t16, 0] : 0 <= t14 <= 63 and 0 <= t15 <= 63 and 0 <= t16 <= 319 }
<legal>



input01:0 0 1 0 ,
icomp00:1 0 0 0 ,0 1 0 0 ,

icomp00:1 0 0 0 ,0 1 0 0 ,
input03:1 0 0 0 ,0 1 0 0 ,0 0 1 0 ,
Schedule number 25
Evaluation : 1.443530
Number of measurements : 3
===================================

parallelization unrolling: .*P\(\{(C[0-9],)*C0(,C[0-9])*\},L2\)U.*|.*P\(\{(C[0-9],)*C1(,C[0-9])*\},L2\)U.*
parallelization tiling: .*P\(\{(C[0-9],)*C0(,C[0-9])*\},L2\)T2\(\{(C[0-9],)*C0(,C[0-9])*\},L0,L1.*|.*P\(\{(C[0-9],)*C1(,C[0-9])*\},L2\)T2\(\{(C[0-9],)*C1(,C[0-9])*\},L0,L1.*
else
transform_ast

-----------
Matrix Transform 3x3 {comp00, } [1, 0, 0, 0, 1, 0, 0, 0, 1]
Matrix Transform 3x3 {comp01, } [1, 0, 0, 0, 1, 0, 0, 0, 1]
Matrix Transform 2x2 {comp00, comp01, } [1, 0, 0, -1]
Parallelize L0 { comp00, comp01, }
0- for 0 <= i0 < 64 | 0 | P
	1- for -63 <= i1 < 1 | 0
		2- for 0 <= i2 < 320 | 0
			comp00
		2- for 0 <= i3 < 320 | 0
			comp01

<legal>

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf02.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf02"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf02 = _halide_buffer_get_host(buf02.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input03_b2[float64 * 320 * 64 * 64]
  allocate _input01_b1[float64 * 320]
  allocate _icomp00_b0[float64 * 64 * 64]
  allocate _comp01_b4[float64 * 320 * 64 * 64]
  allocate _comp00_b3[float64 * 320 * 64 * 64]
  parallel (c1, 0, 64) {
    for (c3, -63, 64) {
      for (c5, 0, 320) {
        buf00[(int32((int64(c1)*(int64)64)) - c3)] = ((1.000000 - (buf01[c5]*1.260000))*buf00[(int32((int64(c1)*(int64)64)) - c3)])
      }
      for (c5, 0, 320) {
        buf02[((c5 + int32((int64((0 - c3))*(int64)320))) + int32((int64(c1)*(int64)20480)))] = (buf00[(int32((int64(c1)*(int64)64)) - c3)] + buf03[((c5 + int32((int64((0 - c3))*(int64)320))) + int32((int64(c1)*(int64)20480)))])
      }
    }
  }
}

<legal>
Schedule number 26
Evaluation : 1.444330
Number of measurements : 3
===================================

parallelization unrolling: .*P\(\{(C[0-9],)*C0(,C[0-9])*\},L2\)U.*|.*P\(\{(C[0-9],)*C1(,C[0-9])*\},L2\)U.*
parallelization tiling: .*P\(\{(C[0-9],)*C0(,C[0-9])*\},L2\)T2\(\{(C[0-9],)*C0(,C[0-9])*\},L0,L1.*|.*P\(\{(C[0-9],)*C1(,C[0-9])*\},L2\)T2\(\{(C[0-9],)*C1(,C[0-9])*\},L0,L1.*
else
transform_ast

-----------
Matrix Transform 3x3 {comp00, } [1, 0, 0, 0, 1, 0, 0, 0, 1]
Matrix Transform 3x3 {comp01, } [1, 0, 0, 0, 1, 0, 0, 0, 1]
Matrix Transform 2x2 {comp00, comp01, } [1, 0, 0, -1]
Parallelize L1 { comp00, comp01, }
0- for 0 <= i0 < 64 | 0
	1- for -63 <= i1 < 1 | 0 | P
		2- for 0 <= i2 < 320 | 0
			comp00
		2- for 0 <= i3 < 320 | 0
			comp01

<legal>

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf02.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf02"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf02 = _halide_buffer_get_host(buf02.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input03_b2[float64 * 320 * 64 * 64]
  allocate _input01_b1[float64 * 320]
  allocate _icomp00_b0[float64 * 64 * 64]
  allocate _comp01_b4[float64 * 320 * 64 * 64]
  allocate _comp00_b3[float64 * 320 * 64 * 64]
  for (c1, 0, 64) {
    parallel (c3, -63, 64) {
      for (c5, 0, 320) {
        buf00[(int32((int64(c1)*(int64)64)) - c3)] = ((1.000000 - (buf01[c5]*1.260000))*buf00[(int32((int64(c1)*(int64)64)) - c3)])
      }
      for (c5, 0, 320) {
        buf02[((c5 + int32((int64((0 - c3))*(int64)320))) + int32((int64(c1)*(int64)20480)))] = (buf00[(int32((int64(c1)*(int64)64)) - c3)] + buf03[((c5 + int32((int64((0 - c3))*(int64)320))) + int32((int64(c1)*(int64)20480)))])
      }
    }
  }
}

<legal>
Schedule number 27
Evaluation : 1.481250
Number of measurements : 3
===================================

parallelization unrolling: .*P\(\{(C[0-9],)*C0(,C[0-9])*\},L2\)U.*|.*P\(\{(C[0-9],)*C1(,C[0-9])*\},L2\)U.*
parallelization tiling: .*P\(\{(C[0-9],)*C0(,C[0-9])*\},L2\)T2\(\{(C[0-9],)*C0(,C[0-9])*\},L0,L1.*|.*P\(\{(C[0-9],)*C1(,C[0-9])*\},L2\)T2\(\{(C[0-9],)*C1(,C[0-9])*\},L0,L1.*
else
transform_ast

-----------
Matrix Transform 3x3 {comp00, } [1, 0, 0, 0, 1, 0, 0, 0, 1]
Matrix Transform 3x3 {comp01, } [1, 0, 0, 0, 1, 0, 0, 0, 1]
Matrix Transform 2x2 {comp00, comp01, } [1, 0, 0, -1]
Parallelize L2 { comp01, }
0- for 0 <= i0 < 64 | 0
	1- for -63 <= i1 < 1 | 0
		2- for 0 <= i2 < 320 | 0
			comp00
		2- for 0 <= i3 < 320 | 0 | P
			comp01

<legal>
set to default

<legal>
Schedule number 28
Evaluation : 0.000000
Number of measurements : 1
===================================

parallelization unrolling: .*P\(\{(C[0-9],)*C0(,C[0-9])*\},L2\)U.*|.*P\(\{(C[0-9],)*C1(,C[0-9])*\},L2\)U.*
parallelization tiling: .*P\(\{(C[0-9],)*C0(,C[0-9])*\},L2\)T2\(\{(C[0-9],)*C0(,C[0-9])*\},L0,L1.*|.*P\(\{(C[0-9],)*C1(,C[0-9])*\},L2\)T2\(\{(C[0-9],)*C1(,C[0-9])*\},L0,L1.*
if

-----------
Matrix Transform 3x3 {comp00, } [1, 0, 0, 0, 1, 0, 0, 0, 1]
Matrix Transform 3x3 {comp01, } [1, 0, 0, 0, 1, 0, 0, 0, 1]
Matrix Transform 2x2 {comp00, comp01, } [1, 0, 0, -1]
Parallelize L2 { comp01, }
Tiling L0 32 L1 32 { comp00, comp01, }
0- for 0 <= i0 < 64 | 0
	1- for -63 <= i1 < 1 | 0
		2- for 0 <= i2 < 320 | 0
			comp00
		2- for 0 <= i3 < 320 | 0 | P
			comp01

<Schedule pruned>
parallelization unrolling: .*P\(\{(C[0-9],)*C0(,C[0-9])*\},L2\)U.*|.*P\(\{(C[0-9],)*C1(,C[0-9])*\},L2\)U.*
if

-----------
Matrix Transform 3x3 {comp00, } [1, 0, 0, 0, 1, 0, 0, 0, 1]
Matrix Transform 3x3 {comp01, } [1, 0, 0, 0, 1, 0, 0, 0, 1]
Matrix Transform 2x2 {comp00, comp01, } [1, 0, 0, -1]
Parallelize L2 { comp01, }
Unrolling L2 4 { comp00, }
0- for 0 <= i0 < 64 | 0
	1- for -63 <= i1 < 1 | 0
		2- for 0 <= i2 < 320 | 0
			comp00
		2- for 0 <= i3 < 320 | 0 | P
			comp01

<Schedule pruned>
parallelization unrolling: .*P\(\{(C[0-9],)*C0(,C[0-9])*\},L2\)U.*|.*P\(\{(C[0-9],)*C1(,C[0-9])*\},L2\)U.*
if

-----------
Matrix Transform 3x3 {comp00, } [1, 0, 0, 0, 1, 0, 0, 0, 1]
Matrix Transform 3x3 {comp01, } [1, 0, 0, 0, 1, 0, 0, 0, 1]
Matrix Transform 2x2 {comp00, comp01, } [1, 0, 0, -1]
Parallelize L2 { comp01, }
Unrolling L2 8 { comp00, }
0- for 0 <= i0 < 64 | 0
	1- for -63 <= i1 < 1 | 0
		2- for 0 <= i2 < 320 | 0
			comp00
		2- for 0 <= i3 < 320 | 0 | P
			comp01

<Schedule pruned>
parallelization unrolling: .*P\(\{(C[0-9],)*C0(,C[0-9])*\},L2\)U.*|.*P\(\{(C[0-9],)*C1(,C[0-9])*\},L2\)U.*
if

-----------
Matrix Transform 3x3 {comp00, } [1, 0, 0, 0, 1, 0, 0, 0, 1]
Matrix Transform 3x3 {comp01, } [1, 0, 0, 0, 1, 0, 0, 0, 1]
Matrix Transform 2x2 {comp00, comp01, } [1, 0, 0, -1]
Parallelize L2 { comp01, }
Unrolling L2 16 { comp00, }
0- for 0 <= i0 < 64 | 0
	1- for -63 <= i1 < 1 | 0
		2- for 0 <= i2 < 320 | 0
			comp00
		2- for 0 <= i3 < 320 | 0 | P
			comp01

<Schedule pruned>
parallelization unrolling: .*P\(\{(C[0-9],)*C0(,C[0-9])*\},L2\)U.*|.*P\(\{(C[0-9],)*C1(,C[0-9])*\},L2\)U.*
parallelization tiling: .*P\(\{(C[0-9],)*C0(,C[0-9])*\},L2\)T2\(\{(C[0-9],)*C0(,C[0-9])*\},L0,L1.*|.*P\(\{(C[0-9],)*C1(,C[0-9])*\},L2\)T2\(\{(C[0-9],)*C1(,C[0-9])*\},L0,L1.*
else
transform_ast

-----------
Matrix Transform 3x3 {comp00, } [1, 0, 0, 0, 1, 0, 0, 0, 1]
Matrix Transform 3x3 {comp01, } [1, 0, 0, 0, 1, 0, 0, 0, 1]
Matrix Transform 2x2 {comp00, comp01, } [1, 0, 0, -1]
Tiling L0 32 L1 32 { comp00, comp01, }
0- for 0 <= i0_outer < 2 | 0
	1- for 0 <= i1_outer < 1 | 0
		2- for 0 <= i0_inner < 32 | 0
			3- for 0 <= i1_inner < 32 | 0
				4- for 0 <= i2 < 320 | 0
					comp00
				4- for 0 <= i3 < 320 | 0
					comp01

<legal>

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf02.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf02"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf02 = _halide_buffer_get_host(buf02.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input03_b2[float64 * 320 * 64 * 64]
  allocate _input01_b1[float64 * 320]
  allocate _icomp00_b0[float64 * 64 * 64]
  allocate _comp01_b4[float64 * 320 * 64 * 64]
  allocate _comp00_b3[float64 * 320 * 64 * 64]
  for (c1, 0, 2) {
    for (c3, -2, 3) {
      for (c5, 0, 32) {
        for (c7, (-63 - min((c3*32), -63)), ((min((c3*-32), 31) + min((c3*32), -63)) + 64)) {
          for (c9, 0, 320) {
            buf00[(((c3*-32) - c7) + int32((int64(((c1*32) + c5))*(int64)64)))] = ((1.000000 - (buf01[c9]*1.260000))*buf00[(((c3*-32) - c7) + int32((int64(((c1*32) + c5))*(int64)64)))])
          }
          for (c9, 0, 320) {
            buf02[((c9 + int32((int64(((c3*-32) - c7))*(int64)320))) + int32((int64(((c1*32) + c5))*(int64)20480)))] = (buf00[(((c3*-32) - c7) + int32((int64(((c1*32) + c5))*(int64)64)))] + buf03[((c9 + int32((int64(((c3*-32) - c7))*(int64)320))) + int32((int64(((c1*32) + c5))*(int64)20480)))])
          }
        }
      }
    }
  }
}

<legal>
Schedule number 29
Evaluation : 1.264190
Number of measurements : 3
===================================

parallelization unrolling: .*P\(\{(C[0-9],)*C0(,C[0-9])*\},L2\)U.*|.*P\(\{(C[0-9],)*C1(,C[0-9])*\},L2\)U.*
parallelization tiling: .*P\(\{(C[0-9],)*C0(,C[0-9])*\},L2\)T2\(\{(C[0-9],)*C0(,C[0-9])*\},L0,L1.*|.*P\(\{(C[0-9],)*C1(,C[0-9])*\},L2\)T2\(\{(C[0-9],)*C1(,C[0-9])*\},L0,L1.*
else
transform_ast

-----------
Matrix Transform 3x3 {comp00, } [1, 0, 0, 0, 1, 0, 0, 0, 1]
Matrix Transform 3x3 {comp01, } [1, 0, 0, 0, 1, 0, 0, 0, 1]
Matrix Transform 2x2 {comp00, comp01, } [1, 0, 0, -1]
Unrolling L2 4 { comp00, }
0- for 0 <= i0 < 64 | 0
	1- for -63 <= i1 < 1 | 0
		2- for 0 <= i2_outer < 80 | 0
			3- for 0 <= i2_inner < 4 | 1
				comp00
		2- for 0 <= i3 < 320 | 0
			comp01

<legal>

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf02.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf02"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf02 = _halide_buffer_get_host(buf02.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input03_b2[float64 * 320 * 64 * 64]
  allocate _input01_b1[float64 * 320]
  allocate _icomp00_b0[float64 * 64 * 64]
  allocate _comp01_b4[float64 * 320 * 64 * 64]
  allocate _comp00_b3[float64 * 320 * 64 * 64]
  for (c1, 0, 64) {
    for (c3, -63, 64) {
      for (c5, 0, 80) {
        unrolled (c7, 0, 4) {
          buf00[(int32((int64(c1)*(int64)64)) - c3)] = ((1.000000 - (buf01[((c5*4) + c7)]*1.260000))*buf00[(int32((int64(c1)*(int64)64)) - c3)])
        }
      }
      for (c5, 0, 320) {
        buf02[((c5 + int32((int64((0 - c3))*(int64)320))) + int32((int64(c1)*(int64)20480)))] = (buf00[(int32((int64(c1)*(int64)64)) - c3)] + buf03[((c5 + int32((int64((0 - c3))*(int64)320))) + int32((int64(c1)*(int64)20480)))])
      }
    }
  }
}

<legal>
Schedule number 30
Evaluation : 1.663140
Number of measurements : 3
===================================

parallelization unrolling: .*P\(\{(C[0-9],)*C0(,C[0-9])*\},L2\)U.*|.*P\(\{(C[0-9],)*C1(,C[0-9])*\},L2\)U.*
parallelization tiling: .*P\(\{(C[0-9],)*C0(,C[0-9])*\},L2\)T2\(\{(C[0-9],)*C0(,C[0-9])*\},L0,L1.*|.*P\(\{(C[0-9],)*C1(,C[0-9])*\},L2\)T2\(\{(C[0-9],)*C1(,C[0-9])*\},L0,L1.*
else
transform_ast

-----------
Matrix Transform 3x3 {comp00, } [1, 0, 0, 0, 1, 0, 0, 0, 1]
Matrix Transform 3x3 {comp01, } [1, 0, 0, 0, 1, 0, 0, 0, 1]
Matrix Transform 2x2 {comp00, comp01, } [1, 0, 0, -1]
Unrolling L2 8 { comp00, }
0- for 0 <= i0 < 64 | 0
	1- for -63 <= i1 < 1 | 0
		2- for 0 <= i2_outer < 40 | 0
			3- for 0 <= i2_inner < 8 | 1
				comp00
		2- for 0 <= i3 < 320 | 0
			comp01

<legal>

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf02.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf02"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf02 = _halide_buffer_get_host(buf02.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input03_b2[float64 * 320 * 64 * 64]
  allocate _input01_b1[float64 * 320]
  allocate _icomp00_b0[float64 * 64 * 64]
  allocate _comp01_b4[float64 * 320 * 64 * 64]
  allocate _comp00_b3[float64 * 320 * 64 * 64]
  for (c1, 0, 64) {
    for (c3, -63, 64) {
      for (c5, 0, 40) {
        unrolled (c7, 0, 8) {
          buf00[(int32((int64(c1)*(int64)64)) - c3)] = ((1.000000 - (buf01[((c5*8) + c7)]*1.260000))*buf00[(int32((int64(c1)*(int64)64)) - c3)])
        }
      }
      for (c5, 0, 320) {
        buf02[((c5 + int32((int64((0 - c3))*(int64)320))) + int32((int64(c1)*(int64)20480)))] = (buf00[(int32((int64(c1)*(int64)64)) - c3)] + buf03[((c5 + int32((int64((0 - c3))*(int64)320))) + int32((int64(c1)*(int64)20480)))])
      }
    }
  }
}

<legal>
Schedule number 31
Evaluation : 1.453940
Number of measurements : 3
===================================

parallelization unrolling: .*P\(\{(C[0-9],)*C0(,C[0-9])*\},L2\)U.*|.*P\(\{(C[0-9],)*C1(,C[0-9])*\},L2\)U.*
parallelization tiling: .*P\(\{(C[0-9],)*C0(,C[0-9])*\},L2\)T2\(\{(C[0-9],)*C0(,C[0-9])*\},L0,L1.*|.*P\(\{(C[0-9],)*C1(,C[0-9])*\},L2\)T2\(\{(C[0-9],)*C1(,C[0-9])*\},L0,L1.*
else
transform_ast

-----------
Matrix Transform 3x3 {comp00, } [1, 0, 0, 0, 1, 0, 0, 0, 1]
Matrix Transform 3x3 {comp01, } [1, 0, 0, 0, 1, 0, 0, 0, 1]
Matrix Transform 2x2 {comp00, comp01, } [1, 0, 0, -1]
Unrolling L2 16 { comp00, }
0- for 0 <= i0 < 64 | 0
	1- for -63 <= i1 < 1 | 0
		2- for 0 <= i2_outer < 20 | 0
			3- for 0 <= i2_inner < 16 | 1
				comp00
		2- for 0 <= i3 < 320 | 0
			comp01

<legal>

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf02.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf02"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf02 = _halide_buffer_get_host(buf02.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input03_b2[float64 * 320 * 64 * 64]
  allocate _input01_b1[float64 * 320]
  allocate _icomp00_b0[float64 * 64 * 64]
  allocate _comp01_b4[float64 * 320 * 64 * 64]
  allocate _comp00_b3[float64 * 320 * 64 * 64]
  for (c1, 0, 64) {
    for (c3, -63, 64) {
      for (c5, 0, 20) {
        unrolled (c7, 0, 16) {
          buf00[(int32((int64(c1)*(int64)64)) - c3)] = ((1.000000 - (buf01[((c5*16) + c7)]*1.260000))*buf00[(int32((int64(c1)*(int64)64)) - c3)])
        }
      }
      for (c5, 0, 320) {
        buf02[((c5 + int32((int64((0 - c3))*(int64)320))) + int32((int64(c1)*(int64)20480)))] = (buf00[(int32((int64(c1)*(int64)64)) - c3)] + buf03[((c5 + int32((int64((0 - c3))*(int64)320))) + int32((int64(c1)*(int64)20480)))])
      }
    }
  }
}

<legal>
Schedule number 32
Evaluation : 2.008520
Number of measurements : 3
===================================

parallelization unrolling: .*P\(\{(C[0-9],)*C0(,C[0-9])*\},L2\)U.*|.*P\(\{(C[0-9],)*C1(,C[0-9])*\},L2\)U.*
parallelization tiling: .*P\(\{(C[0-9],)*C0(,C[0-9])*\},L2\)T2\(\{(C[0-9],)*C0(,C[0-9])*\},L0,L1.*|.*P\(\{(C[0-9],)*C1(,C[0-9])*\},L2\)T2\(\{(C[0-9],)*C1(,C[0-9])*\},L0,L1.*
else
transform_ast

-----------
Matrix Transform 3x3 {comp00, } [1, 0, 0, 0, 1, 0, 0, 0, 1]
Matrix Transform 3x3 {comp01, } [1, 0, 0, 0, 1, 0, 0, 0, 1]
Matrix Transform 2x2 {comp00, comp01, } [1, 0, 0, -1]
Unrolling L2 4 { comp01, }
0- for 0 <= i0 < 64 | 0
	1- for -63 <= i1 < 1 | 0
		2- for 0 <= i2 < 320 | 0
			comp00
		2- for 0 <= i3_outer < 80 | 0
			3- for 0 <= i3_inner < 4 | 1
				comp01

<legal>

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf02.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf02"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf02 = _halide_buffer_get_host(buf02.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input03_b2[float64 * 320 * 64 * 64]
  allocate _input01_b1[float64 * 320]
  allocate _icomp00_b0[float64 * 64 * 64]
  allocate _comp01_b4[float64 * 320 * 64 * 64]
  allocate _comp00_b3[float64 * 320 * 64 * 64]
  for (c1, 0, 64) {
    for (c3, -63, 64) {
      for (c5, 0, 320) {
        buf00[(int32((int64(c1)*(int64)64)) - c3)] = ((1.000000 - (buf01[c5]*1.260000))*buf00[(int32((int64(c1)*(int64)64)) - c3)])
      }
      for (c5, 0, 80) {
        unrolled (c7, 0, 4) {
          buf02[((((c5*4) + c7) + int32((int64((0 - c3))*(int64)320))) + int32((int64(c1)*(int64)20480)))] = (buf00[(int32((int64(c1)*(int64)64)) - c3)] + buf03[((((c5*4) + c7) + int32((int64((0 - c3))*(int64)320))) + int32((int64(c1)*(int64)20480)))])
        }
      }
    }
  }
}

<legal>
Schedule number 33
Evaluation : 1.455240
Number of measurements : 3
===================================

parallelization unrolling: .*P\(\{(C[0-9],)*C0(,C[0-9])*\},L2\)U.*|.*P\(\{(C[0-9],)*C1(,C[0-9])*\},L2\)U.*
parallelization tiling: .*P\(\{(C[0-9],)*C0(,C[0-9])*\},L2\)T2\(\{(C[0-9],)*C0(,C[0-9])*\},L0,L1.*|.*P\(\{(C[0-9],)*C1(,C[0-9])*\},L2\)T2\(\{(C[0-9],)*C1(,C[0-9])*\},L0,L1.*
else
transform_ast

-----------
Matrix Transform 3x3 {comp00, } [1, 0, 0, 0, 1, 0, 0, 0, 1]
Matrix Transform 3x3 {comp01, } [1, 0, 0, 0, 1, 0, 0, 0, 1]
Matrix Transform 2x2 {comp00, comp01, } [1, 0, 0, -1]
Unrolling L2 8 { comp01, }
0- for 0 <= i0 < 64 | 0
	1- for -63 <= i1 < 1 | 0
		2- for 0 <= i2 < 320 | 0
			comp00
		2- for 0 <= i3_outer < 40 | 0
			3- for 0 <= i3_inner < 8 | 1
				comp01

<legal>

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf02.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf02"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf02 = _halide_buffer_get_host(buf02.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input03_b2[float64 * 320 * 64 * 64]
  allocate _input01_b1[float64 * 320]
  allocate _icomp00_b0[float64 * 64 * 64]
  allocate _comp01_b4[float64 * 320 * 64 * 64]
  allocate _comp00_b3[float64 * 320 * 64 * 64]
  for (c1, 0, 64) {
    for (c3, -63, 64) {
      for (c5, 0, 320) {
        buf00[(int32((int64(c1)*(int64)64)) - c3)] = ((1.000000 - (buf01[c5]*1.260000))*buf00[(int32((int64(c1)*(int64)64)) - c3)])
      }
      for (c5, 0, 40) {
        unrolled (c7, 0, 8) {
          buf02[((((c5*8) + c7) + int32((int64((0 - c3))*(int64)320))) + int32((int64(c1)*(int64)20480)))] = (buf00[(int32((int64(c1)*(int64)64)) - c3)] + buf03[((((c5*8) + c7) + int32((int64((0 - c3))*(int64)320))) + int32((int64(c1)*(int64)20480)))])
        }
      }
    }
  }
}

<legal>
Schedule number 34
Evaluation : 1.384200
Number of measurements : 3
===================================

parallelization unrolling: .*P\(\{(C[0-9],)*C0(,C[0-9])*\},L2\)U.*|.*P\(\{(C[0-9],)*C1(,C[0-9])*\},L2\)U.*
parallelization tiling: .*P\(\{(C[0-9],)*C0(,C[0-9])*\},L2\)T2\(\{(C[0-9],)*C0(,C[0-9])*\},L0,L1.*|.*P\(\{(C[0-9],)*C1(,C[0-9])*\},L2\)T2\(\{(C[0-9],)*C1(,C[0-9])*\},L0,L1.*
else
transform_ast

-----------
Matrix Transform 3x3 {comp00, } [1, 0, 0, 0, 1, 0, 0, 0, 1]
Matrix Transform 3x3 {comp01, } [1, 0, 0, 0, 1, 0, 0, 0, 1]
Matrix Transform 2x2 {comp00, comp01, } [1, 0, 0, -1]
Unrolling L2 16 { comp01, }
0- for 0 <= i0 < 64 | 0
	1- for -63 <= i1 < 1 | 0
		2- for 0 <= i2 < 320 | 0
			comp00
		2- for 0 <= i3_outer < 20 | 0
			3- for 0 <= i3_inner < 16 | 1
				comp01

<legal>

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf02.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf02"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf02 = _halide_buffer_get_host(buf02.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input03_b2[float64 * 320 * 64 * 64]
  allocate _input01_b1[float64 * 320]
  allocate _icomp00_b0[float64 * 64 * 64]
  allocate _comp01_b4[float64 * 320 * 64 * 64]
  allocate _comp00_b3[float64 * 320 * 64 * 64]
  for (c1, 0, 64) {
    for (c3, -63, 64) {
      for (c5, 0, 320) {
        buf00[(int32((int64(c1)*(int64)64)) - c3)] = ((1.000000 - (buf01[c5]*1.260000))*buf00[(int32((int64(c1)*(int64)64)) - c3)])
      }
      for (c5, 0, 20) {
        unrolled (c7, 0, 16) {
          buf02[((((c5*16) + c7) + int32((int64((0 - c3))*(int64)320))) + int32((int64(c1)*(int64)20480)))] = (buf00[(int32((int64(c1)*(int64)64)) - c3)] + buf03[((((c5*16) + c7) + int32((int64((0 - c3))*(int64)320))) + int32((int64(c1)*(int64)20480)))])
        }
      }
    }
  }
}

<legal>
Schedule number 35
Evaluation : 1.836640
Number of measurements : 3
===================================

parallelization unrolling: .*P\(\{(C[0-9],)*C0(,C[0-9])*\},L2\)U.*|.*P\(\{(C[0-9],)*C1(,C[0-9])*\},L2\)U.*
parallelization tiling: .*P\(\{(C[0-9],)*C0(,C[0-9])*\},L2\)T2\(\{(C[0-9],)*C0(,C[0-9])*\},L0,L1.*|.*P\(\{(C[0-9],)*C1(,C[0-9])*\},L2\)T2\(\{(C[0-9],)*C1(,C[0-9])*\},L0,L1.*
else
transform_ast

-----------
Matrix Transform 3x3 {comp00, } [1, 0, 0, 0, 1, 0, 0, 0, 1]
Matrix Transform 3x3 {comp01, } [1, 0, 0, 0, 1, 0, 0, 0, 1]
Matrix Transform 2x2 {comp00, comp01, } [1, 0, 0, -1]
Tiling L0 32 L1 32 { comp00, comp01, }
Unrolling L4 4 { comp00, }
0- for 0 <= i0_outer < 2 | 0
	1- for 0 <= i1_outer < 1 | 0
		2- for 0 <= i0_inner < 32 | 0
			3- for 0 <= i1_inner < 32 | 0
				4- for 0 <= i2_outer < 80 | 0
					5- for 0 <= i2_inner < 4 | 1
						comp00
				4- for 0 <= i3 < 320 | 0
					comp01

<legal>

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf02.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf02"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf02 = _halide_buffer_get_host(buf02.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input03_b2[float64 * 320 * 64 * 64]
  allocate _input01_b1[float64 * 320]
  allocate _icomp00_b0[float64 * 64 * 64]
  allocate _comp01_b4[float64 * 320 * 64 * 64]
  allocate _comp00_b3[float64 * 320 * 64 * 64]
  for (c1, 0, 2) {
    for (c3, -2, 3) {
      for (c5, 0, 32) {
        for (c7, (-63 - min((c3*32), -63)), ((min((c3*-32), 31) + min((c3*32), -63)) + 64)) {
          for (c9, 0, 80) {
            unrolled (c11, 0, 4) {
              buf00[(((c3*-32) - c7) + int32((int64(((c1*32) + c5))*(int64)64)))] = ((1.000000 - (buf01[((c9*4) + c11)]*1.260000))*buf00[(((c3*-32) - c7) + int32((int64(((c1*32) + c5))*(int64)64)))])
            }
          }
          for (c9, 0, 320) {
            buf02[((c9 + int32((int64(((c3*-32) - c7))*(int64)320))) + int32((int64(((c1*32) + c5))*(int64)20480)))] = (buf00[(((c3*-32) - c7) + int32((int64(((c1*32) + c5))*(int64)64)))] + buf03[((c9 + int32((int64(((c3*-32) - c7))*(int64)320))) + int32((int64(((c1*32) + c5))*(int64)20480)))])
          }
        }
      }
    }
  }
}

<legal>
Schedule number 36
Evaluation : 1.414770
Number of measurements : 3
===================================

parallelization unrolling: .*P\(\{(C[0-9],)*C0(,C[0-9])*\},L2\)U.*|.*P\(\{(C[0-9],)*C1(,C[0-9])*\},L2\)U.*
parallelization tiling: .*P\(\{(C[0-9],)*C0(,C[0-9])*\},L2\)T2\(\{(C[0-9],)*C0(,C[0-9])*\},L0,L1.*|.*P\(\{(C[0-9],)*C1(,C[0-9])*\},L2\)T2\(\{(C[0-9],)*C1(,C[0-9])*\},L0,L1.*
else
transform_ast

-----------
Matrix Transform 3x3 {comp00, } [1, 0, 0, 0, 1, 0, 0, 0, 1]
Matrix Transform 3x3 {comp01, } [1, 0, 0, 0, 1, 0, 0, 0, 1]
Matrix Transform 2x2 {comp00, comp01, } [1, 0, 0, -1]
Tiling L0 32 L1 32 { comp00, comp01, }
Unrolling L4 8 { comp00, }
0- for 0 <= i0_outer < 2 | 0
	1- for 0 <= i1_outer < 1 | 0
		2- for 0 <= i0_inner < 32 | 0
			3- for 0 <= i1_inner < 32 | 0
				4- for 0 <= i2_outer < 40 | 0
					5- for 0 <= i2_inner < 8 | 1
						comp00
				4- for 0 <= i3 < 320 | 0
					comp01

<legal>

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf02.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf02"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf02 = _halide_buffer_get_host(buf02.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input03_b2[float64 * 320 * 64 * 64]
  allocate _input01_b1[float64 * 320]
  allocate _icomp00_b0[float64 * 64 * 64]
  allocate _comp01_b4[float64 * 320 * 64 * 64]
  allocate _comp00_b3[float64 * 320 * 64 * 64]
  for (c1, 0, 2) {
    for (c3, -2, 3) {
      for (c5, 0, 32) {
        for (c7, (-63 - min((c3*32), -63)), ((min((c3*-32), 31) + min((c3*32), -63)) + 64)) {
          for (c9, 0, 40) {
            unrolled (c11, 0, 8) {
              buf00[(((c3*-32) - c7) + int32((int64(((c1*32) + c5))*(int64)64)))] = ((1.000000 - (buf01[((c9*8) + c11)]*1.260000))*buf00[(((c3*-32) - c7) + int32((int64(((c1*32) + c5))*(int64)64)))])
            }
          }
          for (c9, 0, 320) {
            buf02[((c9 + int32((int64(((c3*-32) - c7))*(int64)320))) + int32((int64(((c1*32) + c5))*(int64)20480)))] = (buf00[(((c3*-32) - c7) + int32((int64(((c1*32) + c5))*(int64)64)))] + buf03[((c9 + int32((int64(((c3*-32) - c7))*(int64)320))) + int32((int64(((c1*32) + c5))*(int64)20480)))])
          }
        }
      }
    }
  }
}

<legal>
Schedule number 37
Evaluation : 2.023970
Number of measurements : 3
===================================

parallelization unrolling: .*P\(\{(C[0-9],)*C0(,C[0-9])*\},L2\)U.*|.*P\(\{(C[0-9],)*C1(,C[0-9])*\},L2\)U.*
parallelization tiling: .*P\(\{(C[0-9],)*C0(,C[0-9])*\},L2\)T2\(\{(C[0-9],)*C0(,C[0-9])*\},L0,L1.*|.*P\(\{(C[0-9],)*C1(,C[0-9])*\},L2\)T2\(\{(C[0-9],)*C1(,C[0-9])*\},L0,L1.*
else
transform_ast

-----------
Matrix Transform 3x3 {comp00, } [1, 0, 0, 0, 1, 0, 0, 0, 1]
Matrix Transform 3x3 {comp01, } [1, 0, 0, 0, 1, 0, 0, 0, 1]
Matrix Transform 2x2 {comp00, comp01, } [1, 0, 0, -1]
Tiling L0 32 L1 32 { comp00, comp01, }
Unrolling L4 16 { comp00, }
0- for 0 <= i0_outer < 2 | 0
	1- for 0 <= i1_outer < 1 | 0
		2- for 0 <= i0_inner < 32 | 0
			3- for 0 <= i1_inner < 32 | 0
				4- for 0 <= i2_outer < 20 | 0
					5- for 0 <= i2_inner < 16 | 1
						comp00
				4- for 0 <= i3 < 320 | 0
					comp01

<legal>

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf02.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf02"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf02 = _halide_buffer_get_host(buf02.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input03_b2[float64 * 320 * 64 * 64]
  allocate _input01_b1[float64 * 320]
  allocate _icomp00_b0[float64 * 64 * 64]
  allocate _comp01_b4[float64 * 320 * 64 * 64]
  allocate _comp00_b3[float64 * 320 * 64 * 64]
  for (c1, 0, 2) {
    for (c3, -2, 3) {
      for (c5, 0, 32) {
        for (c7, (-63 - min((c3*32), -63)), ((min((c3*-32), 31) + min((c3*32), -63)) + 64)) {
          for (c9, 0, 20) {
            unrolled (c11, 0, 16) {
              buf00[(((c3*-32) - c7) + int32((int64(((c1*32) + c5))*(int64)64)))] = ((1.000000 - (buf01[((c9*16) + c11)]*1.260000))*buf00[(((c3*-32) - c7) + int32((int64(((c1*32) + c5))*(int64)64)))])
            }
          }
          for (c9, 0, 320) {
            buf02[((c9 + int32((int64(((c3*-32) - c7))*(int64)320))) + int32((int64(((c1*32) + c5))*(int64)20480)))] = (buf00[(((c3*-32) - c7) + int32((int64(((c1*32) + c5))*(int64)64)))] + buf03[((c9 + int32((int64(((c3*-32) - c7))*(int64)320))) + int32((int64(((c1*32) + c5))*(int64)20480)))])
          }
        }
      }
    }
  }
}

<legal>
Schedule number 38
Evaluation : 1.761460
Number of measurements : 3
===================================

parallelization unrolling: .*P\(\{(C[0-9],)*C0(,C[0-9])*\},L2\)U.*|.*P\(\{(C[0-9],)*C1(,C[0-9])*\},L2\)U.*
parallelization tiling: .*P\(\{(C[0-9],)*C0(,C[0-9])*\},L2\)T2\(\{(C[0-9],)*C0(,C[0-9])*\},L0,L1.*|.*P\(\{(C[0-9],)*C1(,C[0-9])*\},L2\)T2\(\{(C[0-9],)*C1(,C[0-9])*\},L0,L1.*
else
transform_ast

-----------
Matrix Transform 3x3 {comp00, } [1, 0, 0, 0, 1, 0, 0, 0, 1]
Matrix Transform 3x3 {comp01, } [1, 0, 0, 0, 1, 0, 0, 0, 1]
Matrix Transform 2x2 {comp00, comp01, } [1, 0, 0, -1]
Tiling L0 32 L1 32 { comp00, comp01, }
Unrolling L4 4 { comp01, }
0- for 0 <= i0_outer < 2 | 0
	1- for 0 <= i1_outer < 1 | 0
		2- for 0 <= i0_inner < 32 | 0
			3- for 0 <= i1_inner < 32 | 0
				4- for 0 <= i2 < 320 | 0
					comp00
				4- for 0 <= i3_outer < 80 | 0
					5- for 0 <= i3_inner < 4 | 1
						comp01

<legal>

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf02.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf02"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf02 = _halide_buffer_get_host(buf02.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input03_b2[float64 * 320 * 64 * 64]
  allocate _input01_b1[float64 * 320]
  allocate _icomp00_b0[float64 * 64 * 64]
  allocate _comp01_b4[float64 * 320 * 64 * 64]
  allocate _comp00_b3[float64 * 320 * 64 * 64]
  for (c1, 0, 2) {
    for (c3, -2, 3) {
      for (c5, 0, 32) {
        for (c7, (-63 - min((c3*32), -63)), ((min((c3*-32), 31) + min((c3*32), -63)) + 64)) {
          for (c9, 0, 320) {
            buf00[(((c3*-32) - c7) + int32((int64(((c1*32) + c5))*(int64)64)))] = ((1.000000 - (buf01[c9]*1.260000))*buf00[(((c3*-32) - c7) + int32((int64(((c1*32) + c5))*(int64)64)))])
          }
          for (c9, 0, 80) {
            unrolled (c11, 0, 4) {
              buf02[((((c9*4) + c11) + int32((int64(((c3*-32) - c7))*(int64)320))) + int32((int64(((c1*32) + c5))*(int64)20480)))] = (buf00[(((c3*-32) - c7) + int32((int64(((c1*32) + c5))*(int64)64)))] + buf03[((((c9*4) + c11) + int32((int64(((c3*-32) - c7))*(int64)320))) + int32((int64(((c1*32) + c5))*(int64)20480)))])
            }
          }
        }
      }
    }
  }
}

<legal>
Schedule number 39
Evaluation : 1.668130
Number of measurements : 3
===================================

parallelization unrolling: .*P\(\{(C[0-9],)*C0(,C[0-9])*\},L2\)U.*|.*P\(\{(C[0-9],)*C1(,C[0-9])*\},L2\)U.*
parallelization tiling: .*P\(\{(C[0-9],)*C0(,C[0-9])*\},L2\)T2\(\{(C[0-9],)*C0(,C[0-9])*\},L0,L1.*|.*P\(\{(C[0-9],)*C1(,C[0-9])*\},L2\)T2\(\{(C[0-9],)*C1(,C[0-9])*\},L0,L1.*
else
transform_ast

-----------
Matrix Transform 3x3 {comp00, } [1, 0, 0, 0, 1, 0, 0, 0, 1]
Matrix Transform 3x3 {comp01, } [1, 0, 0, 0, 1, 0, 0, 0, 1]
Matrix Transform 2x2 {comp00, comp01, } [1, 0, 0, -1]
Tiling L0 32 L1 32 { comp00, comp01, }
Unrolling L4 8 { comp01, }
0- for 0 <= i0_outer < 2 | 0
	1- for 0 <= i1_outer < 1 | 0
		2- for 0 <= i0_inner < 32 | 0
			3- for 0 <= i1_inner < 32 | 0
				4- for 0 <= i2 < 320 | 0
					comp00
				4- for 0 <= i3_outer < 40 | 0
					5- for 0 <= i3_inner < 8 | 1
						comp01

<legal>

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf02.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf02"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf02 = _halide_buffer_get_host(buf02.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input03_b2[float64 * 320 * 64 * 64]
  allocate _input01_b1[float64 * 320]
  allocate _icomp00_b0[float64 * 64 * 64]
  allocate _comp01_b4[float64 * 320 * 64 * 64]
  allocate _comp00_b3[float64 * 320 * 64 * 64]
  for (c1, 0, 2) {
    for (c3, -2, 3) {
      for (c5, 0, 32) {
        for (c7, (-63 - min((c3*32), -63)), ((min((c3*-32), 31) + min((c3*32), -63)) + 64)) {
          for (c9, 0, 320) {
            buf00[(((c3*-32) - c7) + int32((int64(((c1*32) + c5))*(int64)64)))] = ((1.000000 - (buf01[c9]*1.260000))*buf00[(((c3*-32) - c7) + int32((int64(((c1*32) + c5))*(int64)64)))])
          }
          for (c9, 0, 40) {
            unrolled (c11, 0, 8) {
              buf02[((((c9*8) + c11) + int32((int64(((c3*-32) - c7))*(int64)320))) + int32((int64(((c1*32) + c5))*(int64)20480)))] = (buf00[(((c3*-32) - c7) + int32((int64(((c1*32) + c5))*(int64)64)))] + buf03[((((c9*8) + c11) + int32((int64(((c3*-32) - c7))*(int64)320))) + int32((int64(((c1*32) + c5))*(int64)20480)))])
            }
          }
        }
      }
    }
  }
}

<legal>
Schedule number 40
Evaluation : 1.803330
Number of measurements : 3
===================================

parallelization unrolling: .*P\(\{(C[0-9],)*C0(,C[0-9])*\},L2\)U.*|.*P\(\{(C[0-9],)*C1(,C[0-9])*\},L2\)U.*
parallelization tiling: .*P\(\{(C[0-9],)*C0(,C[0-9])*\},L2\)T2\(\{(C[0-9],)*C0(,C[0-9])*\},L0,L1.*|.*P\(\{(C[0-9],)*C1(,C[0-9])*\},L2\)T2\(\{(C[0-9],)*C1(,C[0-9])*\},L0,L1.*
else
transform_ast

-----------
Matrix Transform 3x3 {comp00, } [1, 0, 0, 0, 1, 0, 0, 0, 1]
Matrix Transform 3x3 {comp01, } [1, 0, 0, 0, 1, 0, 0, 0, 1]
Matrix Transform 2x2 {comp00, comp01, } [1, 0, 0, -1]
Tiling L0 32 L1 32 { comp00, comp01, }
Unrolling L4 16 { comp01, }
0- for 0 <= i0_outer < 2 | 0
	1- for 0 <= i1_outer < 1 | 0
		2- for 0 <= i0_inner < 32 | 0
			3- for 0 <= i1_inner < 32 | 0
				4- for 0 <= i2 < 320 | 0
					comp00
				4- for 0 <= i3_outer < 20 | 0
					5- for 0 <= i3_inner < 16 | 1
						comp01

<legal>

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf02.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf02"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf02 = _halide_buffer_get_host(buf02.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input03_b2[float64 * 320 * 64 * 64]
  allocate _input01_b1[float64 * 320]
  allocate _icomp00_b0[float64 * 64 * 64]
  allocate _comp01_b4[float64 * 320 * 64 * 64]
  allocate _comp00_b3[float64 * 320 * 64 * 64]
  for (c1, 0, 2) {
    for (c3, -2, 3) {
      for (c5, 0, 32) {
        for (c7, (-63 - min((c3*32), -63)), ((min((c3*-32), 31) + min((c3*32), -63)) + 64)) {
          for (c9, 0, 320) {
            buf00[(((c3*-32) - c7) + int32((int64(((c1*32) + c5))*(int64)64)))] = ((1.000000 - (buf01[c9]*1.260000))*buf00[(((c3*-32) - c7) + int32((int64(((c1*32) + c5))*(int64)64)))])
          }
          for (c9, 0, 20) {
            unrolled (c11, 0, 16) {
              buf02[((((c9*16) + c11) + int32((int64(((c3*-32) - c7))*(int64)320))) + int32((int64(((c1*32) + c5))*(int64)20480)))] = (buf00[(((c3*-32) - c7) + int32((int64(((c1*32) + c5))*(int64)64)))] + buf03[((((c9*16) + c11) + int32((int64(((c3*-32) - c7))*(int64)320))) + int32((int64(((c1*32) + c5))*(int64)20480)))])
            }
          }
        }
      }
    }
  }
}

<legal>
Schedule number 41
Evaluation : 1.320210
Number of measurements : 3
===================================


-----------
Matrix Transform 3x3 {comp00, } [1, 0, 0, 0, 1, 0, 0, 0, 1]
Matrix Transform 3x3 {comp01, } [1, 0, 0, 0, 1, 0, 0, 0, 1]
Matrix Transform 2x2 {comp00, comp01, } [1, 0, 0, -1]
Matrix Transform 3x3 {comp01, } [1, 0, 0, 0, 1, 0, 0, 0, -1]
Matrix Transform 2x2 {comp00, comp01, } [0, 1, 1, 0]
0- for -63 <= i0 < 1 | 0
	1- for 0 <= i1 < 64 | 0
		2- for 0 <= i2 < 320 | 0
			comp00
		2- for -319 <= i3 < 1 | 0
			comp01
{ comp00[t10, t11, t12] -> comp00[0, 0, t224 = -t11, 0, t225 = t10, 0, t226 = t12, 0] : 0 <= t10 <= 63 and 0 <= t11 <= 63 and 0 <= t12 <= 319 }{ comp01[t14, t15, t16] -> comp01[0, 0, t227 = -t15, 0, t228 = t14, 10, t229 = -t16, 0] : 0 <= t14 <= 63 and 0 <= t15 <= 63 and 0 <= t16 <= 319 }
<legal>



input01:0 0 1 0 ,
icomp00:1 0 0 0 ,0 1 0 0 ,

icomp00:1 0 0 0 ,0 1 0 0 ,
input03:1 0 0 0 ,0 1 0 0 ,0 0 1 0 ,

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf02.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf02"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf02 = _halide_buffer_get_host(buf02.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input03_b2[float64 * 320 * 64 * 64]
  allocate _input01_b1[float64 * 320]
  allocate _icomp00_b0[float64 * 64 * 64]
  allocate _comp01_b4[float64 * 320 * 64 * 64]
  allocate _comp00_b3[float64 * 320 * 64 * 64]
  for (c1, -63, 64) {
    for (c3, 0, 64) {
      for (c5, 0, 320) {
        buf00[(int32((int64(c3)*(int64)64)) - c1)] = ((1.000000 - (buf01[c5]*1.260000))*buf00[(int32((int64(c3)*(int64)64)) - c1)])
      }
      for (c5, -319, 320) {
        buf02[((int32((int64((0 - c1))*(int64)320)) - c5) + int32((int64(c3)*(int64)20480)))] = (buf00[(int32((int64(c3)*(int64)64)) - c1)] + buf03[((int32((int64((0 - c1))*(int64)320)) - c5) + int32((int64(c3)*(int64)20480)))])
      }
    }
  }
}
{ comp00[t10, t11, t12] -> comp00[0, 0, t224 = -t11, 0, t225 = t10, 0, t226 = t12, 0] : 0 <= t10 <= 63 and 0 <= t11 <= 63 and 0 <= t12 <= 319 }{ comp01[t14, t15, t16] -> comp01[0, 0, t227 = -t15, 0, t228 = t14, 10, t229 = -t16, 0] : 0 <= t14 <= 63 and 0 <= t15 <= 63 and 0 <= t16 <= 319 }
<legal>



input01:0 0 1 0 ,
icomp00:1 0 0 0 ,0 1 0 0 ,

icomp00:1 0 0 0 ,0 1 0 0 ,
input03:1 0 0 0 ,0 1 0 0 ,0 0 1 0 ,
Schedule number 42
Evaluation : 2.138270
Number of measurements : 3
===================================


-----------
Matrix Transform 3x3 {comp00, } [1, 0, 0, 0, 1, 0, 0, 0, 1]
Matrix Transform 3x3 {comp01, } [1, 0, 0, 0, 1, 0, 0, 0, 1]
Matrix Transform 2x2 {comp00, comp01, } [1, 0, 0, -1]
Matrix Transform 3x3 {comp01, } [1, 0, 0, 0, 1, 0, 0, 0, -1]
Matrix Transform 2x2 {comp00, comp01, } [-1, 0, 0, 1]
0- for -63 <= i0 < 1 | 0
	1- for -63 <= i1 < 1 | 0
		2- for 0 <= i2 < 320 | 0
			comp00
		2- for -319 <= i3 < 1 | 0
			comp01
{ comp00[t10, t11, t12] -> comp00[0, 0, t238 = -t10, 0, t239 = -t11, 0, t240 = t12, 0] : 0 <= t10 <= 63 and 0 <= t11 <= 63 and 0 <= t12 <= 319 }{ comp01[t14, t15, t16] -> comp01[0, 0, t241 = -t14, 0, t242 = -t15, 10, t243 = -t16, 0] : 0 <= t14 <= 63 and 0 <= t15 <= 63 and 0 <= t16 <= 319 }
<legal>



input01:0 0 1 0 ,
icomp00:1 0 0 0 ,0 1 0 0 ,

icomp00:1 0 0 0 ,0 1 0 0 ,
input03:1 0 0 0 ,0 1 0 0 ,0 0 1 0 ,

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf02.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf02"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf02 = _halide_buffer_get_host(buf02.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input03_b2[float64 * 320 * 64 * 64]
  allocate _input01_b1[float64 * 320]
  allocate _icomp00_b0[float64 * 64 * 64]
  allocate _comp01_b4[float64 * 320 * 64 * 64]
  allocate _comp00_b3[float64 * 320 * 64 * 64]
  for (c1, -63, 64) {
    for (c3, -63, 64) {
      for (c5, 0, 320) {
        buf00[(int32((int64((0 - c1))*(int64)64)) - c3)] = ((1.000000 - (buf01[c5]*1.260000))*buf00[(int32((int64((0 - c1))*(int64)64)) - c3)])
      }
      for (c5, -319, 320) {
        buf02[((int32((int64((0 - c3))*(int64)320)) - c5) + int32((int64((0 - c1))*(int64)20480)))] = (buf00[(int32((int64((0 - c1))*(int64)64)) - c3)] + buf03[((int32((int64((0 - c3))*(int64)320)) - c5) + int32((int64((0 - c1))*(int64)20480)))])
      }
    }
  }
}
{ comp00[t10, t11, t12] -> comp00[0, 0, t238 = -t10, 0, t239 = -t11, 0, t240 = t12, 0] : 0 <= t10 <= 63 and 0 <= t11 <= 63 and 0 <= t12 <= 319 }{ comp01[t14, t15, t16] -> comp01[0, 0, t241 = -t14, 0, t242 = -t15, 10, t243 = -t16, 0] : 0 <= t14 <= 63 and 0 <= t15 <= 63 and 0 <= t16 <= 319 }
<legal>



input01:0 0 1 0 ,
icomp00:1 0 0 0 ,0 1 0 0 ,

icomp00:1 0 0 0 ,0 1 0 0 ,
input03:1 0 0 0 ,0 1 0 0 ,0 0 1 0 ,
Schedule number 43
Evaluation : 1.415620
Number of measurements : 3
===================================


-----------
Matrix Transform 3x3 {comp00, } [1, 0, 0, 0, 1, 0, 0, 0, 1]
Matrix Transform 3x3 {comp01, } [1, 0, 0, 0, 1, 0, 0, 0, 1]
Matrix Transform 2x2 {comp00, comp01, } [1, 0, 0, -1]
Matrix Transform 3x3 {comp01, } [1, 0, 0, 0, 1, 0, 0, 0, -1]
Matrix Transform 3x3 {comp00, } [1, 0, 0, 0, 1, 0, 0, 0, -1]
0- for 0 <= i0 < 64 | 0
	1- for -63 <= i1 < 1 | 0
		2- for -319 <= i2 < 1 | 0
			comp00
		2- for -319 <= i3 < 1 | 0
			comp01
{ comp00[t10, t11, t12] -> comp00[0, 0, t262 = t10, 0, t263 = -t11, 0, t264 = -t12, 0] : 0 <= t10 <= 63 and 0 <= t11 <= 63 and 0 <= t12 <= 319 }{ comp01[t14, t15, t16] -> comp01[0, 0, t153 = t14, 0, t154 = -t15, 10, t155 = -t16, 0] : 0 <= t14 <= 63 and 0 <= t15 <= 63 and 0 <= t16 <= 319 }
<illegal>

-----------
Matrix Transform 3x3 {comp00, } [1, 0, 0, 0, 1, 0, 0, 0, 1]
Matrix Transform 3x3 {comp01, } [1, 0, 0, 0, 1, 0, 0, 0, 1]
Matrix Transform 2x2 {comp00, comp01, } [1, 0, 0, -1]
Matrix Transform 3x3 {comp01, } [1, 0, 0, 0, 1, 0, 0, 0, -1]
Matrix Transform 2x2 {comp00, comp01, } [-1, 0, 0, 1]
Matrix Transform 3x3 {comp00, } [1, 0, 0, 0, 1, 0, 0, 0, -1]
0- for -63 <= i0 < 1 | 0
	1- for -63 <= i1 < 1 | 0
		2- for -319 <= i2 < 1 | 0
			comp00
		2- for -319 <= i3 < 1 | 0
			comp01
{ comp00[t10, t11, t12] -> comp00[0, 0, t276 = -t10, 0, t277 = -t11, 0, t278 = -t12, 0] : 0 <= t10 <= 63 and 0 <= t11 <= 63 and 0 <= t12 <= 319 }{ comp01[t14, t15, t16] -> comp01[0, 0, t241 = -t14, 0, t242 = -t15, 10, t243 = -t16, 0] : 0 <= t14 <= 63 and 0 <= t15 <= 63 and 0 <= t16 <= 319 }
<illegal>

-----------
Matrix Transform 3x3 {comp00, } [1, 0, 0, 0, 1, 0, 0, 0, 1]
Matrix Transform 3x3 {comp01, } [1, 0, 0, 0, 1, 0, 0, 0, 1]
Matrix Transform 2x2 {comp00, comp01, } [1, 0, 0, -1]
Matrix Transform 3x3 {comp01, } [1, 0, 0, 0, 1, 0, 0, 0, -1]
Matrix Transform 2x2 {comp00, comp01, } [-1, 0, 0, 1]
Matrix Transform 3x3 {comp01, } [1, 0, 0, 0, 1, 0, 0, 0, -1]
0- for -63 <= i0 < 1 | 0
	1- for -63 <= i1 < 1 | 0
		2- for 0 <= i2 < 320 | 0
			comp00
		2- for 0 <= i3 < 320 | 0
			comp01
{ comp00[t10, t11, t12] -> comp00[0, 0, t238 = -t10, 0, t239 = -t11, 0, t240 = t12, 0] : 0 <= t10 <= 63 and 0 <= t11 <= 63 and 0 <= t12 <= 319 }{ comp01[t14, t15, t16] -> comp01[0, 0, t283 = -t14, 0, t284 = -t15, 10, t285 = t16, 0] : 0 <= t14 <= 63 and 0 <= t15 <= 63 and 0 <= t16 <= 319 }
<legal>



input01:0 0 1 0 ,
icomp00:1 0 0 0 ,0 1 0 0 ,

icomp00:1 0 0 0 ,0 1 0 0 ,
input03:1 0 0 0 ,0 1 0 0 ,0 0 1 0 ,

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf02.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf02"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf02 = _halide_buffer_get_host(buf02.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input03_b2[float64 * 320 * 64 * 64]
  allocate _input01_b1[float64 * 320]
  allocate _icomp00_b0[float64 * 64 * 64]
  allocate _comp01_b4[float64 * 320 * 64 * 64]
  allocate _comp00_b3[float64 * 320 * 64 * 64]
  for (c1, -63, 64) {
    for (c3, -63, 64) {
      for (c5, 0, 320) {
        buf00[(int32((int64((0 - c1))*(int64)64)) - c3)] = ((1.000000 - (buf01[c5]*1.260000))*buf00[(int32((int64((0 - c1))*(int64)64)) - c3)])
      }
      for (c5, 0, 320) {
        buf02[((c5 + int32((int64((0 - c3))*(int64)320))) + int32((int64((0 - c1))*(int64)20480)))] = (buf00[(int32((int64((0 - c1))*(int64)64)) - c3)] + buf03[((c5 + int32((int64((0 - c3))*(int64)320))) + int32((int64((0 - c1))*(int64)20480)))])
      }
    }
  }
}
{ comp00[t10, t11, t12] -> comp00[0, 0, t238 = -t10, 0, t239 = -t11, 0, t240 = t12, 0] : 0 <= t10 <= 63 and 0 <= t11 <= 63 and 0 <= t12 <= 319 }{ comp01[t14, t15, t16] -> comp01[0, 0, t283 = -t14, 0, t284 = -t15, 10, t285 = t16, 0] : 0 <= t14 <= 63 and 0 <= t15 <= 63 and 0 <= t16 <= 319 }
<legal>



input01:0 0 1 0 ,
icomp00:1 0 0 0 ,0 1 0 0 ,

icomp00:1 0 0 0 ,0 1 0 0 ,
input03:1 0 0 0 ,0 1 0 0 ,0 0 1 0 ,
Schedule number 44
Evaluation : 1.406310
Number of measurements : 3
===================================


-----------
Matrix Transform 3x3 {comp00, } [1, 0, 0, 0, 1, 0, 0, 0, 1]
Matrix Transform 3x3 {comp01, } [1, 0, 0, 0, 1, 0, 0, 0, 1]
Matrix Transform 2x2 {comp00, comp01, } [1, 0, 0, -1]
Matrix Transform 3x3 {comp01, } [1, 0, 0, 0, 1, 0, 0, 0, -1]
Matrix Transform 2x2 {comp00, comp01, } [-1, 0, 0, 1]
Matrix Transform 3x3 {comp01, } [1, 0, 0, 0, 1, 0, 0, 0, -1]
Matrix Transform 2x2 {comp00, comp01, } [0, 1, 1, 0]
0- for -63 <= i0 < 1 | 0
	1- for -63 <= i1 < 1 | 0
		2- for 0 <= i2 < 320 | 0
			comp00
		2- for 0 <= i3 < 320 | 0
			comp01
{ comp00[t10, t11, t12] -> comp00[0, 0, -t11, 0, -t10, 0, t12, 0] : 0 <= t10 <= 63 and 0 <= t11 <= 63 and 0 <= t12 <= 319 }{ comp01[t14, t15, t16] -> comp01[0, 0, -t15, 0, -t14, 10, t16, 0] : 0 <= t14 <= 63 and 0 <= t15 <= 63 and 0 <= t16 <= 319 }
<surpassed MAX_MAT_DEPTH>

-----------
Matrix Transform 3x3 {comp00, } [1, 0, 0, 0, 1, 0, 0, 0, 1]
Matrix Transform 3x3 {comp01, } [1, 0, 0, 0, 1, 0, 0, 0, 1]
Matrix Transform 2x2 {comp00, comp01, } [1, 0, 0, -1]
Matrix Transform 3x3 {comp01, } [1, 0, 0, 0, 1, 0, 0, 0, -1]
Matrix Transform 2x2 {comp00, comp01, } [-1, 0, 0, 1]
Matrix Transform 3x3 {comp01, } [1, 0, 0, 0, 1, 0, 0, 0, -1]
Matrix Transform 2x2 {comp00, comp01, } [-1, 0, 0, 1]
0- for 0 <= i0 < 64 | 0
	1- for -63 <= i1 < 1 | 0
		2- for 0 <= i2 < 320 | 0
			comp00
		2- for 0 <= i3 < 320 | 0
			comp01
{ comp00[t10, t11, t12] -> comp00[0, 0, t10, 0, -t11, 0, t12, 0] : 0 <= t10 <= 63 and 0 <= t11 <= 63 and 0 <= t12 <= 319 }{ comp01[t14, t15, t16] -> comp01[0, 0, t14, 0, -t15, 10, t16, 0] : 0 <= t14 <= 63 and 0 <= t15 <= 63 and 0 <= t16 <= 319 }
<surpassed MAX_MAT_DEPTH>

-----------
Matrix Transform 3x3 {comp00, } [1, 0, 0, 0, 1, 0, 0, 0, 1]
Matrix Transform 3x3 {comp01, } [1, 0, 0, 0, 1, 0, 0, 0, 1]
Matrix Transform 2x2 {comp00, comp01, } [1, 0, 0, -1]
Matrix Transform 3x3 {comp01, } [1, 0, 0, 0, 1, 0, 0, 0, -1]
Matrix Transform 2x2 {comp00, comp01, } [-1, 0, 0, 1]
Matrix Transform 3x3 {comp01, } [1, 0, 0, 0, 1, 0, 0, 0, -1]
Matrix Transform 2x2 {comp00, comp01, } [1, 0, 0, -1]
0- for -63 <= i0 < 1 | 0
	1- for 0 <= i1 < 64 | 0
		2- for 0 <= i2 < 320 | 0
			comp00
		2- for 0 <= i3 < 320 | 0
			comp01
{ comp00[t10, t11, t12] -> comp00[0, 0, -t10, 0, t11, 0, t12, 0] : 0 <= t10 <= 63 and 0 <= t11 <= 63 and 0 <= t12 <= 319 }{ comp01[t14, t15, t16] -> comp01[0, 0, -t14, 0, t15, 10, t16, 0] : 0 <= t14 <= 63 and 0 <= t15 <= 63 and 0 <= t16 <= 319 }
<surpassed MAX_MAT_DEPTH>

-----------
Matrix Transform 3x3 {comp00, } [1, 0, 0, 0, 1, 0, 0, 0, 1]
Matrix Transform 3x3 {comp01, } [1, 0, 0, 0, 1, 0, 0, 0, 1]
Matrix Transform 2x2 {comp00, comp01, } [1, 0, 0, -1]
Matrix Transform 3x3 {comp01, } [1, 0, 0, 0, 1, 0, 0, 0, -1]
Matrix Transform 2x2 {comp00, comp01, } [-1, 0, 0, 1]
Matrix Transform 3x3 {comp01, } [1, 0, 0, 0, 1, 0, 0, 0, -1]
Matrix Transform 3x3 {comp00, } [1, 0, 0, 0, 1, 0, 0, 0, -1]
0- for -63 <= i0 < 1 | 0
	1- for -63 <= i1 < 1 | 0
		2- for -319 <= i2 < 1 | 0
			comp00
		2- for 0 <= i3 < 320 | 0
			comp01
{ comp00[t10, t11, t12] -> comp00[0, 0, t314 = -t10, 0, t315 = -t11, 0, t316 = -t12, 0] : 0 <= t10 <= 63 and 0 <= t11 <= 63 and 0 <= t12 <= 319 }{ comp01[t14, t15, t16] -> comp01[0, 0, t283 = -t14, 0, t284 = -t15, 10, t285 = t16, 0] : 0 <= t14 <= 63 and 0 <= t15 <= 63 and 0 <= t16 <= 319 }
<illegal>

-----------
Matrix Transform 3x3 {comp00, } [1, 0, 0, 0, 1, 0, 0, 0, 1]
Matrix Transform 3x3 {comp01, } [1, 0, 0, 0, 1, 0, 0, 0, 1]
Matrix Transform 2x2 {comp00, comp01, } [1, 0, 0, -1]
Matrix Transform 3x3 {comp01, } [1, 0, 0, 0, 1, 0, 0, 0, -1]
Matrix Transform 2x2 {comp00, comp01, } [-1, 0, 0, 1]
Matrix Transform 3x3 {comp01, } [1, 0, 0, 0, 1, 0, 0, 0, -1]
Matrix Transform 3x3 {comp01, } [1, 0, 0, 0, 1, 0, 0, 0, -1]
0- for -63 <= i0 < 1 | 0
	1- for -63 <= i1 < 1 | 0
		2- for 0 <= i2 < 320 | 0
			comp00
		2- for -319 <= i3 < 1 | 0
			comp01
{ comp00[t10, t11, t12] -> comp00[0, 0, t238 = -t10, 0, t239 = -t11, 0, t240 = t12, 0] : 0 <= t10 <= 63 and 0 <= t11 <= 63 and 0 <= t12 <= 319 }{ comp01[t14, t15, t16] -> comp01[0, 0, -t14, 0, -t15, 10, -t16, 0] : 0 <= t14 <= 63 and 0 <= t15 <= 63 and 0 <= t16 <= 319 }
<surpassed MAX_MAT_DEPTH>
parallelization unrolling: .*P\(\{(C[0-9],)*C0(,C[0-9])*\},L2\)U.*|.*P\(\{(C[0-9],)*C1(,C[0-9])*\},L2\)U.*
parallelization tiling: .*P\(\{(C[0-9],)*C0(,C[0-9])*\},L2\)T2\(\{(C[0-9],)*C0(,C[0-9])*\},L0,L1.*|.*P\(\{(C[0-9],)*C1(,C[0-9])*\},L2\)T2\(\{(C[0-9],)*C1(,C[0-9])*\},L0,L1.*
else
transform_ast

-----------
Matrix Transform 3x3 {comp00, } [1, 0, 0, 0, 1, 0, 0, 0, 1]
Matrix Transform 3x3 {comp01, } [1, 0, 0, 0, 1, 0, 0, 0, 1]
Matrix Transform 2x2 {comp00, comp01, } [1, 0, 0, -1]
Matrix Transform 3x3 {comp01, } [1, 0, 0, 0, 1, 0, 0, 0, -1]
Matrix Transform 2x2 {comp00, comp01, } [-1, 0, 0, 1]
Matrix Transform 3x3 {comp01, } [1, 0, 0, 0, 1, 0, 0, 0, -1]
Parallelize L0 { comp00, comp01, }
0- for -63 <= i0 < 1 | 0 | P
	1- for -63 <= i1 < 1 | 0
		2- for 0 <= i2 < 320 | 0
			comp00
		2- for 0 <= i3 < 320 | 0
			comp01

<legal>

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf02.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf02"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf02 = _halide_buffer_get_host(buf02.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input03_b2[float64 * 320 * 64 * 64]
  allocate _input01_b1[float64 * 320]
  allocate _icomp00_b0[float64 * 64 * 64]
  allocate _comp01_b4[float64 * 320 * 64 * 64]
  allocate _comp00_b3[float64 * 320 * 64 * 64]
  parallel (c1, -63, 64) {
    for (c3, -63, 64) {
      for (c5, 0, 320) {
        buf00[(int32((int64((0 - c1))*(int64)64)) - c3)] = ((1.000000 - (buf01[c5]*1.260000))*buf00[(int32((int64((0 - c1))*(int64)64)) - c3)])
      }
      for (c5, 0, 320) {
        buf02[((c5 + int32((int64((0 - c3))*(int64)320))) + int32((int64((0 - c1))*(int64)20480)))] = (buf00[(int32((int64((0 - c1))*(int64)64)) - c3)] + buf03[((c5 + int32((int64((0 - c3))*(int64)320))) + int32((int64((0 - c1))*(int64)20480)))])
      }
    }
  }
}

<legal>
Schedule number 45
Evaluation : 1.417100
Number of measurements : 3
===================================

parallelization unrolling: .*P\(\{(C[0-9],)*C0(,C[0-9])*\},L2\)U.*|.*P\(\{(C[0-9],)*C1(,C[0-9])*\},L2\)U.*
parallelization tiling: .*P\(\{(C[0-9],)*C0(,C[0-9])*\},L2\)T2\(\{(C[0-9],)*C0(,C[0-9])*\},L0,L1.*|.*P\(\{(C[0-9],)*C1(,C[0-9])*\},L2\)T2\(\{(C[0-9],)*C1(,C[0-9])*\},L0,L1.*
else
transform_ast

-----------
Matrix Transform 3x3 {comp00, } [1, 0, 0, 0, 1, 0, 0, 0, 1]
Matrix Transform 3x3 {comp01, } [1, 0, 0, 0, 1, 0, 0, 0, 1]
Matrix Transform 2x2 {comp00, comp01, } [1, 0, 0, -1]
Matrix Transform 3x3 {comp01, } [1, 0, 0, 0, 1, 0, 0, 0, -1]
Matrix Transform 2x2 {comp00, comp01, } [-1, 0, 0, 1]
Matrix Transform 3x3 {comp01, } [1, 0, 0, 0, 1, 0, 0, 0, -1]
Parallelize L1 { comp00, comp01, }
0- for -63 <= i0 < 1 | 0
	1- for -63 <= i1 < 1 | 0 | P
		2- for 0 <= i2 < 320 | 0
			comp00
		2- for 0 <= i3 < 320 | 0
			comp01

<legal>

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf02.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf02"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf02 = _halide_buffer_get_host(buf02.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input03_b2[float64 * 320 * 64 * 64]
  allocate _input01_b1[float64 * 320]
  allocate _icomp00_b0[float64 * 64 * 64]
  allocate _comp01_b4[float64 * 320 * 64 * 64]
  allocate _comp00_b3[float64 * 320 * 64 * 64]
  for (c1, -63, 64) {
    parallel (c3, -63, 64) {
      for (c5, 0, 320) {
        buf00[(int32((int64((0 - c1))*(int64)64)) - c3)] = ((1.000000 - (buf01[c5]*1.260000))*buf00[(int32((int64((0 - c1))*(int64)64)) - c3)])
      }
      for (c5, 0, 320) {
        buf02[((c5 + int32((int64((0 - c3))*(int64)320))) + int32((int64((0 - c1))*(int64)20480)))] = (buf00[(int32((int64((0 - c1))*(int64)64)) - c3)] + buf03[((c5 + int32((int64((0 - c3))*(int64)320))) + int32((int64((0 - c1))*(int64)20480)))])
      }
    }
  }
}

<legal>
Schedule number 46
Evaluation : 1.412060
Number of measurements : 3
===================================

parallelization unrolling: .*P\(\{(C[0-9],)*C0(,C[0-9])*\},L2\)U.*|.*P\(\{(C[0-9],)*C1(,C[0-9])*\},L2\)U.*
parallelization tiling: .*P\(\{(C[0-9],)*C0(,C[0-9])*\},L2\)T2\(\{(C[0-9],)*C0(,C[0-9])*\},L0,L1.*|.*P\(\{(C[0-9],)*C1(,C[0-9])*\},L2\)T2\(\{(C[0-9],)*C1(,C[0-9])*\},L0,L1.*
else
transform_ast

-----------
Matrix Transform 3x3 {comp00, } [1, 0, 0, 0, 1, 0, 0, 0, 1]
Matrix Transform 3x3 {comp01, } [1, 0, 0, 0, 1, 0, 0, 0, 1]
Matrix Transform 2x2 {comp00, comp01, } [1, 0, 0, -1]
Matrix Transform 3x3 {comp01, } [1, 0, 0, 0, 1, 0, 0, 0, -1]
Matrix Transform 2x2 {comp00, comp01, } [-1, 0, 0, 1]
Matrix Transform 3x3 {comp01, } [1, 0, 0, 0, 1, 0, 0, 0, -1]
Parallelize L2 { comp01, }
0- for -63 <= i0 < 1 | 0
	1- for -63 <= i1 < 1 | 0
		2- for 0 <= i2 < 320 | 0
			comp00
		2- for 0 <= i3 < 320 | 0 | P
			comp01

<legal>
set to default

<legal>
Schedule number 47
Evaluation : 0.000000
Number of measurements : 1
===================================

parallelization unrolling: .*P\(\{(C[0-9],)*C0(,C[0-9])*\},L2\)U.*|.*P\(\{(C[0-9],)*C1(,C[0-9])*\},L2\)U.*
parallelization tiling: .*P\(\{(C[0-9],)*C0(,C[0-9])*\},L2\)T2\(\{(C[0-9],)*C0(,C[0-9])*\},L0,L1.*|.*P\(\{(C[0-9],)*C1(,C[0-9])*\},L2\)T2\(\{(C[0-9],)*C1(,C[0-9])*\},L0,L1.*
if

-----------
Matrix Transform 3x3 {comp00, } [1, 0, 0, 0, 1, 0, 0, 0, 1]
Matrix Transform 3x3 {comp01, } [1, 0, 0, 0, 1, 0, 0, 0, 1]
Matrix Transform 2x2 {comp00, comp01, } [1, 0, 0, -1]
Matrix Transform 3x3 {comp01, } [1, 0, 0, 0, 1, 0, 0, 0, -1]
Matrix Transform 2x2 {comp00, comp01, } [-1, 0, 0, 1]
Matrix Transform 3x3 {comp01, } [1, 0, 0, 0, 1, 0, 0, 0, -1]
Parallelize L2 { comp01, }
Tiling L0 32 L1 32 { comp00, comp01, }
0- for -63 <= i0 < 1 | 0
	1- for -63 <= i1 < 1 | 0
		2- for 0 <= i2 < 320 | 0
			comp00
		2- for 0 <= i3 < 320 | 0 | P
			comp01

<Schedule pruned>
parallelization unrolling: .*P\(\{(C[0-9],)*C0(,C[0-9])*\},L2\)U.*|.*P\(\{(C[0-9],)*C1(,C[0-9])*\},L2\)U.*
if

-----------
Matrix Transform 3x3 {comp00, } [1, 0, 0, 0, 1, 0, 0, 0, 1]
Matrix Transform 3x3 {comp01, } [1, 0, 0, 0, 1, 0, 0, 0, 1]
Matrix Transform 2x2 {comp00, comp01, } [1, 0, 0, -1]
Matrix Transform 3x3 {comp01, } [1, 0, 0, 0, 1, 0, 0, 0, -1]
Matrix Transform 2x2 {comp00, comp01, } [-1, 0, 0, 1]
Matrix Transform 3x3 {comp01, } [1, 0, 0, 0, 1, 0, 0, 0, -1]
Parallelize L2 { comp01, }
Unrolling L2 4 { comp00, }
0- for -63 <= i0 < 1 | 0
	1- for -63 <= i1 < 1 | 0
		2- for 0 <= i2 < 320 | 0
			comp00
		2- for 0 <= i3 < 320 | 0 | P
			comp01

<Schedule pruned>
parallelization unrolling: .*P\(\{(C[0-9],)*C0(,C[0-9])*\},L2\)U.*|.*P\(\{(C[0-9],)*C1(,C[0-9])*\},L2\)U.*
if

-----------
Matrix Transform 3x3 {comp00, } [1, 0, 0, 0, 1, 0, 0, 0, 1]
Matrix Transform 3x3 {comp01, } [1, 0, 0, 0, 1, 0, 0, 0, 1]
Matrix Transform 2x2 {comp00, comp01, } [1, 0, 0, -1]
Matrix Transform 3x3 {comp01, } [1, 0, 0, 0, 1, 0, 0, 0, -1]
Matrix Transform 2x2 {comp00, comp01, } [-1, 0, 0, 1]
Matrix Transform 3x3 {comp01, } [1, 0, 0, 0, 1, 0, 0, 0, -1]
Parallelize L2 { comp01, }
Unrolling L2 8 { comp00, }
0- for -63 <= i0 < 1 | 0
	1- for -63 <= i1 < 1 | 0
		2- for 0 <= i2 < 320 | 0
			comp00
		2- for 0 <= i3 < 320 | 0 | P
			comp01

<Schedule pruned>
parallelization unrolling: .*P\(\{(C[0-9],)*C0(,C[0-9])*\},L2\)U.*|.*P\(\{(C[0-9],)*C1(,C[0-9])*\},L2\)U.*
if

-----------
Matrix Transform 3x3 {comp00, } [1, 0, 0, 0, 1, 0, 0, 0, 1]
Matrix Transform 3x3 {comp01, } [1, 0, 0, 0, 1, 0, 0, 0, 1]
Matrix Transform 2x2 {comp00, comp01, } [1, 0, 0, -1]
Matrix Transform 3x3 {comp01, } [1, 0, 0, 0, 1, 0, 0, 0, -1]
Matrix Transform 2x2 {comp00, comp01, } [-1, 0, 0, 1]
Matrix Transform 3x3 {comp01, } [1, 0, 0, 0, 1, 0, 0, 0, -1]
Parallelize L2 { comp01, }
Unrolling L2 16 { comp00, }
0- for -63 <= i0 < 1 | 0
	1- for -63 <= i1 < 1 | 0
		2- for 0 <= i2 < 320 | 0
			comp00
		2- for 0 <= i3 < 320 | 0 | P
			comp01

<Schedule pruned>
parallelization unrolling: .*P\(\{(C[0-9],)*C0(,C[0-9])*\},L2\)U.*|.*P\(\{(C[0-9],)*C1(,C[0-9])*\},L2\)U.*
parallelization tiling: .*P\(\{(C[0-9],)*C0(,C[0-9])*\},L2\)T2\(\{(C[0-9],)*C0(,C[0-9])*\},L0,L1.*|.*P\(\{(C[0-9],)*C1(,C[0-9])*\},L2\)T2\(\{(C[0-9],)*C1(,C[0-9])*\},L0,L1.*
else
transform_ast

-----------
Matrix Transform 3x3 {comp00, } [1, 0, 0, 0, 1, 0, 0, 0, 1]
Matrix Transform 3x3 {comp01, } [1, 0, 0, 0, 1, 0, 0, 0, 1]
Matrix Transform 2x2 {comp00, comp01, } [1, 0, 0, -1]
Matrix Transform 3x3 {comp01, } [1, 0, 0, 0, 1, 0, 0, 0, -1]
Matrix Transform 2x2 {comp00, comp01, } [-1, 0, 0, 1]
Matrix Transform 3x3 {comp01, } [1, 0, 0, 0, 1, 0, 0, 0, -1]
Tiling L0 32 L1 32 { comp00, comp01, }
0- for 0 <= i0_outer < 1 | 0
	1- for 0 <= i1_outer < 1 | 0
		2- for 0 <= i0_inner < 32 | 0
			3- for 0 <= i1_inner < 32 | 0
				4- for 0 <= i2 < 320 | 0
					comp00
				4- for 0 <= i3 < 320 | 0
					comp01

<legal>

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf02.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf02"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf02 = _halide_buffer_get_host(buf02.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input03_b2[float64 * 320 * 64 * 64]
  allocate _input01_b1[float64 * 320]
  allocate _icomp00_b0[float64 * 64 * 64]
  allocate _comp01_b4[float64 * 320 * 64 * 64]
  allocate _comp00_b3[float64 * 320 * 64 * 64]
  for (c1, -2, 3) {
    for (c3, -2, 3) {
      for (c5, (-63 - min((c1*32), -63)), ((min((c1*-32), 31) + min((c1*32), -63)) + 64)) {
        for (c7, (-63 - min((c3*32), -63)), ((min((c3*-32), 31) + min((c3*32), -63)) + 64)) {
          for (c9, 0, 320) {
            buf00[(((c3*-32) - c7) + int32((int64(((c1*-32) - c5))*(int64)64)))] = ((1.000000 - (buf01[c9]*1.260000))*buf00[(((c3*-32) - c7) + int32((int64(((c1*-32) - c5))*(int64)64)))])
          }
          for (c9, 0, 320) {
            buf02[((c9 + int32((int64(((c3*-32) - c7))*(int64)320))) + int32((int64(((c1*-32) - c5))*(int64)20480)))] = (buf00[(((c3*-32) - c7) + int32((int64(((c1*-32) - c5))*(int64)64)))] + buf03[((c9 + int32((int64(((c3*-32) - c7))*(int64)320))) + int32((int64(((c1*-32) - c5))*(int64)20480)))])
          }
        }
      }
    }
  }
}

<legal>
Schedule number 48
Evaluation : 1.475950
Number of measurements : 3
===================================

parallelization unrolling: .*P\(\{(C[0-9],)*C0(,C[0-9])*\},L2\)U.*|.*P\(\{(C[0-9],)*C1(,C[0-9])*\},L2\)U.*
parallelization tiling: .*P\(\{(C[0-9],)*C0(,C[0-9])*\},L2\)T2\(\{(C[0-9],)*C0(,C[0-9])*\},L0,L1.*|.*P\(\{(C[0-9],)*C1(,C[0-9])*\},L2\)T2\(\{(C[0-9],)*C1(,C[0-9])*\},L0,L1.*
else
transform_ast

-----------
Matrix Transform 3x3 {comp00, } [1, 0, 0, 0, 1, 0, 0, 0, 1]
Matrix Transform 3x3 {comp01, } [1, 0, 0, 0, 1, 0, 0, 0, 1]
Matrix Transform 2x2 {comp00, comp01, } [1, 0, 0, -1]
Matrix Transform 3x3 {comp01, } [1, 0, 0, 0, 1, 0, 0, 0, -1]
Matrix Transform 2x2 {comp00, comp01, } [-1, 0, 0, 1]
Matrix Transform 3x3 {comp01, } [1, 0, 0, 0, 1, 0, 0, 0, -1]
Unrolling L2 4 { comp00, }
0- for -63 <= i0 < 1 | 0
	1- for -63 <= i1 < 1 | 0
		2- for 0 <= i2_outer < 80 | 0
			3- for 0 <= i2_inner < 4 | 1
				comp00
		2- for 0 <= i3 < 320 | 0
			comp01

<legal>

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf02.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf02"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf02 = _halide_buffer_get_host(buf02.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input03_b2[float64 * 320 * 64 * 64]
  allocate _input01_b1[float64 * 320]
  allocate _icomp00_b0[float64 * 64 * 64]
  allocate _comp01_b4[float64 * 320 * 64 * 64]
  allocate _comp00_b3[float64 * 320 * 64 * 64]
  for (c1, -63, 64) {
    for (c3, -63, 64) {
      for (c5, 0, 80) {
        unrolled (c7, 0, 4) {
          buf00[(int32((int64((0 - c1))*(int64)64)) - c3)] = ((1.000000 - (buf01[((c5*4) + c7)]*1.260000))*buf00[(int32((int64((0 - c1))*(int64)64)) - c3)])
        }
      }
      for (c5, 0, 320) {
        buf02[((c5 + int32((int64((0 - c3))*(int64)320))) + int32((int64((0 - c1))*(int64)20480)))] = (buf00[(int32((int64((0 - c1))*(int64)64)) - c3)] + buf03[((c5 + int32((int64((0 - c3))*(int64)320))) + int32((int64((0 - c1))*(int64)20480)))])
      }
    }
  }
}

<legal>
Schedule number 49
Evaluation : 1.437750
Number of measurements : 3
===================================

parallelization unrolling: .*P\(\{(C[0-9],)*C0(,C[0-9])*\},L2\)U.*|.*P\(\{(C[0-9],)*C1(,C[0-9])*\},L2\)U.*
parallelization tiling: .*P\(\{(C[0-9],)*C0(,C[0-9])*\},L2\)T2\(\{(C[0-9],)*C0(,C[0-9])*\},L0,L1.*|.*P\(\{(C[0-9],)*C1(,C[0-9])*\},L2\)T2\(\{(C[0-9],)*C1(,C[0-9])*\},L0,L1.*
else
transform_ast

-----------
Matrix Transform 3x3 {comp00, } [1, 0, 0, 0, 1, 0, 0, 0, 1]
Matrix Transform 3x3 {comp01, } [1, 0, 0, 0, 1, 0, 0, 0, 1]
Matrix Transform 2x2 {comp00, comp01, } [1, 0, 0, -1]
Matrix Transform 3x3 {comp01, } [1, 0, 0, 0, 1, 0, 0, 0, -1]
Matrix Transform 2x2 {comp00, comp01, } [-1, 0, 0, 1]
Matrix Transform 3x3 {comp01, } [1, 0, 0, 0, 1, 0, 0, 0, -1]
Unrolling L2 8 { comp00, }
0- for -63 <= i0 < 1 | 0
	1- for -63 <= i1 < 1 | 0
		2- for 0 <= i2_outer < 40 | 0
			3- for 0 <= i2_inner < 8 | 1
				comp00
		2- for 0 <= i3 < 320 | 0
			comp01

<legal>

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf02.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf02"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf02 = _halide_buffer_get_host(buf02.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input03_b2[float64 * 320 * 64 * 64]
  allocate _input01_b1[float64 * 320]
  allocate _icomp00_b0[float64 * 64 * 64]
  allocate _comp01_b4[float64 * 320 * 64 * 64]
  allocate _comp00_b3[float64 * 320 * 64 * 64]
  for (c1, -63, 64) {
    for (c3, -63, 64) {
      for (c5, 0, 40) {
        unrolled (c7, 0, 8) {
          buf00[(int32((int64((0 - c1))*(int64)64)) - c3)] = ((1.000000 - (buf01[((c5*8) + c7)]*1.260000))*buf00[(int32((int64((0 - c1))*(int64)64)) - c3)])
        }
      }
      for (c5, 0, 320) {
        buf02[((c5 + int32((int64((0 - c3))*(int64)320))) + int32((int64((0 - c1))*(int64)20480)))] = (buf00[(int32((int64((0 - c1))*(int64)64)) - c3)] + buf03[((c5 + int32((int64((0 - c3))*(int64)320))) + int32((int64((0 - c1))*(int64)20480)))])
      }
    }
  }
}

<legal>
Schedule number 50
Evaluation : 1.701650
Number of measurements : 3
===================================

parallelization unrolling: .*P\(\{(C[0-9],)*C0(,C[0-9])*\},L2\)U.*|.*P\(\{(C[0-9],)*C1(,C[0-9])*\},L2\)U.*
parallelization tiling: .*P\(\{(C[0-9],)*C0(,C[0-9])*\},L2\)T2\(\{(C[0-9],)*C0(,C[0-9])*\},L0,L1.*|.*P\(\{(C[0-9],)*C1(,C[0-9])*\},L2\)T2\(\{(C[0-9],)*C1(,C[0-9])*\},L0,L1.*
else
transform_ast

-----------
Matrix Transform 3x3 {comp00, } [1, 0, 0, 0, 1, 0, 0, 0, 1]
Matrix Transform 3x3 {comp01, } [1, 0, 0, 0, 1, 0, 0, 0, 1]
Matrix Transform 2x2 {comp00, comp01, } [1, 0, 0, -1]
Matrix Transform 3x3 {comp01, } [1, 0, 0, 0, 1, 0, 0, 0, -1]
Matrix Transform 2x2 {comp00, comp01, } [-1, 0, 0, 1]
Matrix Transform 3x3 {comp01, } [1, 0, 0, 0, 1, 0, 0, 0, -1]
Unrolling L2 16 { comp00, }
0- for -63 <= i0 < 1 | 0
	1- for -63 <= i1 < 1 | 0
		2- for 0 <= i2_outer < 20 | 0
			3- for 0 <= i2_inner < 16 | 1
				comp00
		2- for 0 <= i3 < 320 | 0
			comp01

<legal>

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf02.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf02"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf02 = _halide_buffer_get_host(buf02.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input03_b2[float64 * 320 * 64 * 64]
  allocate _input01_b1[float64 * 320]
  allocate _icomp00_b0[float64 * 64 * 64]
  allocate _comp01_b4[float64 * 320 * 64 * 64]
  allocate _comp00_b3[float64 * 320 * 64 * 64]
  for (c1, -63, 64) {
    for (c3, -63, 64) {
      for (c5, 0, 20) {
        unrolled (c7, 0, 16) {
          buf00[(int32((int64((0 - c1))*(int64)64)) - c3)] = ((1.000000 - (buf01[((c5*16) + c7)]*1.260000))*buf00[(int32((int64((0 - c1))*(int64)64)) - c3)])
        }
      }
      for (c5, 0, 320) {
        buf02[((c5 + int32((int64((0 - c3))*(int64)320))) + int32((int64((0 - c1))*(int64)20480)))] = (buf00[(int32((int64((0 - c1))*(int64)64)) - c3)] + buf03[((c5 + int32((int64((0 - c3))*(int64)320))) + int32((int64((0 - c1))*(int64)20480)))])
      }
    }
  }
}

<legal>
Schedule number 51
Evaluation : 1.496270
Number of measurements : 3
===================================

parallelization unrolling: .*P\(\{(C[0-9],)*C0(,C[0-9])*\},L2\)U.*|.*P\(\{(C[0-9],)*C1(,C[0-9])*\},L2\)U.*
parallelization tiling: .*P\(\{(C[0-9],)*C0(,C[0-9])*\},L2\)T2\(\{(C[0-9],)*C0(,C[0-9])*\},L0,L1.*|.*P\(\{(C[0-9],)*C1(,C[0-9])*\},L2\)T2\(\{(C[0-9],)*C1(,C[0-9])*\},L0,L1.*
else
transform_ast

-----------
Matrix Transform 3x3 {comp00, } [1, 0, 0, 0, 1, 0, 0, 0, 1]
Matrix Transform 3x3 {comp01, } [1, 0, 0, 0, 1, 0, 0, 0, 1]
Matrix Transform 2x2 {comp00, comp01, } [1, 0, 0, -1]
Matrix Transform 3x3 {comp01, } [1, 0, 0, 0, 1, 0, 0, 0, -1]
Matrix Transform 2x2 {comp00, comp01, } [-1, 0, 0, 1]
Matrix Transform 3x3 {comp01, } [1, 0, 0, 0, 1, 0, 0, 0, -1]
Unrolling L2 4 { comp01, }
0- for -63 <= i0 < 1 | 0
	1- for -63 <= i1 < 1 | 0
		2- for 0 <= i2 < 320 | 0
			comp00
		2- for 0 <= i3_outer < 80 | 0
			3- for 0 <= i3_inner < 4 | 1
				comp01

<legal>

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf02.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf02"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf02 = _halide_buffer_get_host(buf02.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input03_b2[float64 * 320 * 64 * 64]
  allocate _input01_b1[float64 * 320]
  allocate _icomp00_b0[float64 * 64 * 64]
  allocate _comp01_b4[float64 * 320 * 64 * 64]
  allocate _comp00_b3[float64 * 320 * 64 * 64]
  for (c1, -63, 64) {
    for (c3, -63, 64) {
      for (c5, 0, 320) {
        buf00[(int32((int64((0 - c1))*(int64)64)) - c3)] = ((1.000000 - (buf01[c5]*1.260000))*buf00[(int32((int64((0 - c1))*(int64)64)) - c3)])
      }
      for (c5, 0, 80) {
        unrolled (c7, 0, 4) {
          buf02[((((c5*4) + c7) + int32((int64((0 - c3))*(int64)320))) + int32((int64((0 - c1))*(int64)20480)))] = (buf00[(int32((int64((0 - c1))*(int64)64)) - c3)] + buf03[((((c5*4) + c7) + int32((int64((0 - c3))*(int64)320))) + int32((int64((0 - c1))*(int64)20480)))])
        }
      }
    }
  }
}

<legal>
Schedule number 52
Evaluation : 1.472000
Number of measurements : 3
===================================

parallelization unrolling: .*P\(\{(C[0-9],)*C0(,C[0-9])*\},L2\)U.*|.*P\(\{(C[0-9],)*C1(,C[0-9])*\},L2\)U.*
parallelization tiling: .*P\(\{(C[0-9],)*C0(,C[0-9])*\},L2\)T2\(\{(C[0-9],)*C0(,C[0-9])*\},L0,L1.*|.*P\(\{(C[0-9],)*C1(,C[0-9])*\},L2\)T2\(\{(C[0-9],)*C1(,C[0-9])*\},L0,L1.*
else
transform_ast

-----------
Matrix Transform 3x3 {comp00, } [1, 0, 0, 0, 1, 0, 0, 0, 1]
Matrix Transform 3x3 {comp01, } [1, 0, 0, 0, 1, 0, 0, 0, 1]
Matrix Transform 2x2 {comp00, comp01, } [1, 0, 0, -1]
Matrix Transform 3x3 {comp01, } [1, 0, 0, 0, 1, 0, 0, 0, -1]
Matrix Transform 2x2 {comp00, comp01, } [-1, 0, 0, 1]
Matrix Transform 3x3 {comp01, } [1, 0, 0, 0, 1, 0, 0, 0, -1]
Unrolling L2 8 { comp01, }
0- for -63 <= i0 < 1 | 0
	1- for -63 <= i1 < 1 | 0
		2- for 0 <= i2 < 320 | 0
			comp00
		2- for 0 <= i3_outer < 40 | 0
			3- for 0 <= i3_inner < 8 | 1
				comp01

<legal>

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf02.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf02"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf02 = _halide_buffer_get_host(buf02.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input03_b2[float64 * 320 * 64 * 64]
  allocate _input01_b1[float64 * 320]
  allocate _icomp00_b0[float64 * 64 * 64]
  allocate _comp01_b4[float64 * 320 * 64 * 64]
  allocate _comp00_b3[float64 * 320 * 64 * 64]
  for (c1, -63, 64) {
    for (c3, -63, 64) {
      for (c5, 0, 320) {
        buf00[(int32((int64((0 - c1))*(int64)64)) - c3)] = ((1.000000 - (buf01[c5]*1.260000))*buf00[(int32((int64((0 - c1))*(int64)64)) - c3)])
      }
      for (c5, 0, 40) {
        unrolled (c7, 0, 8) {
          buf02[((((c5*8) + c7) + int32((int64((0 - c3))*(int64)320))) + int32((int64((0 - c1))*(int64)20480)))] = (buf00[(int32((int64((0 - c1))*(int64)64)) - c3)] + buf03[((((c5*8) + c7) + int32((int64((0 - c3))*(int64)320))) + int32((int64((0 - c1))*(int64)20480)))])
        }
      }
    }
  }
}

<legal>
Schedule number 53
Evaluation : 1.359550
Number of measurements : 3
===================================

parallelization unrolling: .*P\(\{(C[0-9],)*C0(,C[0-9])*\},L2\)U.*|.*P\(\{(C[0-9],)*C1(,C[0-9])*\},L2\)U.*
parallelization tiling: .*P\(\{(C[0-9],)*C0(,C[0-9])*\},L2\)T2\(\{(C[0-9],)*C0(,C[0-9])*\},L0,L1.*|.*P\(\{(C[0-9],)*C1(,C[0-9])*\},L2\)T2\(\{(C[0-9],)*C1(,C[0-9])*\},L0,L1.*
else
transform_ast

-----------
Matrix Transform 3x3 {comp00, } [1, 0, 0, 0, 1, 0, 0, 0, 1]
Matrix Transform 3x3 {comp01, } [1, 0, 0, 0, 1, 0, 0, 0, 1]
Matrix Transform 2x2 {comp00, comp01, } [1, 0, 0, -1]
Matrix Transform 3x3 {comp01, } [1, 0, 0, 0, 1, 0, 0, 0, -1]
Matrix Transform 2x2 {comp00, comp01, } [-1, 0, 0, 1]
Matrix Transform 3x3 {comp01, } [1, 0, 0, 0, 1, 0, 0, 0, -1]
Unrolling L2 16 { comp01, }
0- for -63 <= i0 < 1 | 0
	1- for -63 <= i1 < 1 | 0
		2- for 0 <= i2 < 320 | 0
			comp00
		2- for 0 <= i3_outer < 20 | 0
			3- for 0 <= i3_inner < 16 | 1
				comp01

<legal>

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf02.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf02"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf02 = _halide_buffer_get_host(buf02.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input03_b2[float64 * 320 * 64 * 64]
  allocate _input01_b1[float64 * 320]
  allocate _icomp00_b0[float64 * 64 * 64]
  allocate _comp01_b4[float64 * 320 * 64 * 64]
  allocate _comp00_b3[float64 * 320 * 64 * 64]
  for (c1, -63, 64) {
    for (c3, -63, 64) {
      for (c5, 0, 320) {
        buf00[(int32((int64((0 - c1))*(int64)64)) - c3)] = ((1.000000 - (buf01[c5]*1.260000))*buf00[(int32((int64((0 - c1))*(int64)64)) - c3)])
      }
      for (c5, 0, 20) {
        unrolled (c7, 0, 16) {
          buf02[((((c5*16) + c7) + int32((int64((0 - c3))*(int64)320))) + int32((int64((0 - c1))*(int64)20480)))] = (buf00[(int32((int64((0 - c1))*(int64)64)) - c3)] + buf03[((((c5*16) + c7) + int32((int64((0 - c3))*(int64)320))) + int32((int64((0 - c1))*(int64)20480)))])
        }
      }
    }
  }
}

<legal>
Schedule number 54
Evaluation : 1.404710
Number of measurements : 3
===================================

parallelization unrolling: .*P\(\{(C[0-9],)*C0(,C[0-9])*\},L2\)U.*|.*P\(\{(C[0-9],)*C1(,C[0-9])*\},L2\)U.*
parallelization tiling: .*P\(\{(C[0-9],)*C0(,C[0-9])*\},L2\)T2\(\{(C[0-9],)*C0(,C[0-9])*\},L0,L1.*|.*P\(\{(C[0-9],)*C1(,C[0-9])*\},L2\)T2\(\{(C[0-9],)*C1(,C[0-9])*\},L0,L1.*
else
transform_ast

-----------
Matrix Transform 3x3 {comp00, } [1, 0, 0, 0, 1, 0, 0, 0, 1]
Matrix Transform 3x3 {comp01, } [1, 0, 0, 0, 1, 0, 0, 0, 1]
Matrix Transform 2x2 {comp00, comp01, } [1, 0, 0, -1]
Matrix Transform 3x3 {comp01, } [1, 0, 0, 0, 1, 0, 0, 0, -1]
Matrix Transform 2x2 {comp00, comp01, } [-1, 0, 0, 1]
Matrix Transform 3x3 {comp01, } [1, 0, 0, 0, 1, 0, 0, 0, -1]
Tiling L0 32 L1 32 { comp00, comp01, }
Unrolling L4 4 { comp00, }
0- for 0 <= i0_outer < 1 | 0
	1- for 0 <= i1_outer < 1 | 0
		2- for 0 <= i0_inner < 32 | 0
			3- for 0 <= i1_inner < 32 | 0
				4- for 0 <= i2_outer < 80 | 0
					5- for 0 <= i2_inner < 4 | 1
						comp00
				4- for 0 <= i3 < 320 | 0
					comp01

<legal>

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf02.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf02"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf02 = _halide_buffer_get_host(buf02.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input03_b2[float64 * 320 * 64 * 64]
  allocate _input01_b1[float64 * 320]
  allocate _icomp00_b0[float64 * 64 * 64]
  allocate _comp01_b4[float64 * 320 * 64 * 64]
  allocate _comp00_b3[float64 * 320 * 64 * 64]
  for (c1, -2, 3) {
    for (c3, -2, 3) {
      for (c5, (-63 - min((c1*32), -63)), ((min((c1*-32), 31) + min((c1*32), -63)) + 64)) {
        for (c7, (-63 - min((c3*32), -63)), ((min((c3*-32), 31) + min((c3*32), -63)) + 64)) {
          for (c9, 0, 80) {
            unrolled (c11, 0, 4) {
              buf00[(((c3*-32) - c7) + int32((int64(((c1*-32) - c5))*(int64)64)))] = ((1.000000 - (buf01[((c9*4) + c11)]*1.260000))*buf00[(((c3*-32) - c7) + int32((int64(((c1*-32) - c5))*(int64)64)))])
            }
          }
          for (c9, 0, 320) {
            buf02[((c9 + int32((int64(((c3*-32) - c7))*(int64)320))) + int32((int64(((c1*-32) - c5))*(int64)20480)))] = (buf00[(((c3*-32) - c7) + int32((int64(((c1*-32) - c5))*(int64)64)))] + buf03[((c9 + int32((int64(((c3*-32) - c7))*(int64)320))) + int32((int64(((c1*-32) - c5))*(int64)20480)))])
          }
        }
      }
    }
  }
}

<legal>
Schedule number 55
Evaluation : 1.300040
Number of measurements : 3
===================================

parallelization unrolling: .*P\(\{(C[0-9],)*C0(,C[0-9])*\},L2\)U.*|.*P\(\{(C[0-9],)*C1(,C[0-9])*\},L2\)U.*
parallelization tiling: .*P\(\{(C[0-9],)*C0(,C[0-9])*\},L2\)T2\(\{(C[0-9],)*C0(,C[0-9])*\},L0,L1.*|.*P\(\{(C[0-9],)*C1(,C[0-9])*\},L2\)T2\(\{(C[0-9],)*C1(,C[0-9])*\},L0,L1.*
else
transform_ast

-----------
Matrix Transform 3x3 {comp00, } [1, 0, 0, 0, 1, 0, 0, 0, 1]
Matrix Transform 3x3 {comp01, } [1, 0, 0, 0, 1, 0, 0, 0, 1]
Matrix Transform 2x2 {comp00, comp01, } [1, 0, 0, -1]
Matrix Transform 3x3 {comp01, } [1, 0, 0, 0, 1, 0, 0, 0, -1]
Matrix Transform 2x2 {comp00, comp01, } [-1, 0, 0, 1]
Matrix Transform 3x3 {comp01, } [1, 0, 0, 0, 1, 0, 0, 0, -1]
Tiling L0 32 L1 32 { comp00, comp01, }
Unrolling L4 8 { comp00, }
0- for 0 <= i0_outer < 1 | 0
	1- for 0 <= i1_outer < 1 | 0
		2- for 0 <= i0_inner < 32 | 0
			3- for 0 <= i1_inner < 32 | 0
				4- for 0 <= i2_outer < 40 | 0
					5- for 0 <= i2_inner < 8 | 1
						comp00
				4- for 0 <= i3 < 320 | 0
					comp01

<legal>

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf02.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf02"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf02 = _halide_buffer_get_host(buf02.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input03_b2[float64 * 320 * 64 * 64]
  allocate _input01_b1[float64 * 320]
  allocate _icomp00_b0[float64 * 64 * 64]
  allocate _comp01_b4[float64 * 320 * 64 * 64]
  allocate _comp00_b3[float64 * 320 * 64 * 64]
  for (c1, -2, 3) {
    for (c3, -2, 3) {
      for (c5, (-63 - min((c1*32), -63)), ((min((c1*-32), 31) + min((c1*32), -63)) + 64)) {
        for (c7, (-63 - min((c3*32), -63)), ((min((c3*-32), 31) + min((c3*32), -63)) + 64)) {
          for (c9, 0, 40) {
            unrolled (c11, 0, 8) {
              buf00[(((c3*-32) - c7) + int32((int64(((c1*-32) - c5))*(int64)64)))] = ((1.000000 - (buf01[((c9*8) + c11)]*1.260000))*buf00[(((c3*-32) - c7) + int32((int64(((c1*-32) - c5))*(int64)64)))])
            }
          }
          for (c9, 0, 320) {
            buf02[((c9 + int32((int64(((c3*-32) - c7))*(int64)320))) + int32((int64(((c1*-32) - c5))*(int64)20480)))] = (buf00[(((c3*-32) - c7) + int32((int64(((c1*-32) - c5))*(int64)64)))] + buf03[((c9 + int32((int64(((c3*-32) - c7))*(int64)320))) + int32((int64(((c1*-32) - c5))*(int64)20480)))])
          }
        }
      }
    }
  }
}

<legal>
Schedule number 56
Evaluation : 1.616900
Number of measurements : 3
===================================

parallelization unrolling: .*P\(\{(C[0-9],)*C0(,C[0-9])*\},L2\)U.*|.*P\(\{(C[0-9],)*C1(,C[0-9])*\},L2\)U.*
parallelization tiling: .*P\(\{(C[0-9],)*C0(,C[0-9])*\},L2\)T2\(\{(C[0-9],)*C0(,C[0-9])*\},L0,L1.*|.*P\(\{(C[0-9],)*C1(,C[0-9])*\},L2\)T2\(\{(C[0-9],)*C1(,C[0-9])*\},L0,L1.*
else
transform_ast

-----------
Matrix Transform 3x3 {comp00, } [1, 0, 0, 0, 1, 0, 0, 0, 1]
Matrix Transform 3x3 {comp01, } [1, 0, 0, 0, 1, 0, 0, 0, 1]
Matrix Transform 2x2 {comp00, comp01, } [1, 0, 0, -1]
Matrix Transform 3x3 {comp01, } [1, 0, 0, 0, 1, 0, 0, 0, -1]
Matrix Transform 2x2 {comp00, comp01, } [-1, 0, 0, 1]
Matrix Transform 3x3 {comp01, } [1, 0, 0, 0, 1, 0, 0, 0, -1]
Tiling L0 32 L1 32 { comp00, comp01, }
Unrolling L4 16 { comp00, }
0- for 0 <= i0_outer < 1 | 0
	1- for 0 <= i1_outer < 1 | 0
		2- for 0 <= i0_inner < 32 | 0
			3- for 0 <= i1_inner < 32 | 0
				4- for 0 <= i2_outer < 20 | 0
					5- for 0 <= i2_inner < 16 | 1
						comp00
				4- for 0 <= i3 < 320 | 0
					comp01

<legal>

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf02.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf02"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf02 = _halide_buffer_get_host(buf02.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input03_b2[float64 * 320 * 64 * 64]
  allocate _input01_b1[float64 * 320]
  allocate _icomp00_b0[float64 * 64 * 64]
  allocate _comp01_b4[float64 * 320 * 64 * 64]
  allocate _comp00_b3[float64 * 320 * 64 * 64]
  for (c1, -2, 3) {
    for (c3, -2, 3) {
      for (c5, (-63 - min((c1*32), -63)), ((min((c1*-32), 31) + min((c1*32), -63)) + 64)) {
        for (c7, (-63 - min((c3*32), -63)), ((min((c3*-32), 31) + min((c3*32), -63)) + 64)) {
          for (c9, 0, 20) {
            unrolled (c11, 0, 16) {
              buf00[(((c3*-32) - c7) + int32((int64(((c1*-32) - c5))*(int64)64)))] = ((1.000000 - (buf01[((c9*16) + c11)]*1.260000))*buf00[(((c3*-32) - c7) + int32((int64(((c1*-32) - c5))*(int64)64)))])
            }
          }
          for (c9, 0, 320) {
            buf02[((c9 + int32((int64(((c3*-32) - c7))*(int64)320))) + int32((int64(((c1*-32) - c5))*(int64)20480)))] = (buf00[(((c3*-32) - c7) + int32((int64(((c1*-32) - c5))*(int64)64)))] + buf03[((c9 + int32((int64(((c3*-32) - c7))*(int64)320))) + int32((int64(((c1*-32) - c5))*(int64)20480)))])
          }
        }
      }
    }
  }
}

<legal>
Schedule number 57
Evaluation : 1.316710
Number of measurements : 3
===================================

parallelization unrolling: .*P\(\{(C[0-9],)*C0(,C[0-9])*\},L2\)U.*|.*P\(\{(C[0-9],)*C1(,C[0-9])*\},L2\)U.*
parallelization tiling: .*P\(\{(C[0-9],)*C0(,C[0-9])*\},L2\)T2\(\{(C[0-9],)*C0(,C[0-9])*\},L0,L1.*|.*P\(\{(C[0-9],)*C1(,C[0-9])*\},L2\)T2\(\{(C[0-9],)*C1(,C[0-9])*\},L0,L1.*
else
transform_ast

-----------
Matrix Transform 3x3 {comp00, } [1, 0, 0, 0, 1, 0, 0, 0, 1]
Matrix Transform 3x3 {comp01, } [1, 0, 0, 0, 1, 0, 0, 0, 1]
Matrix Transform 2x2 {comp00, comp01, } [1, 0, 0, -1]
Matrix Transform 3x3 {comp01, } [1, 0, 0, 0, 1, 0, 0, 0, -1]
Matrix Transform 2x2 {comp00, comp01, } [-1, 0, 0, 1]
Matrix Transform 3x3 {comp01, } [1, 0, 0, 0, 1, 0, 0, 0, -1]
Tiling L0 32 L1 32 { comp00, comp01, }
Unrolling L4 4 { comp01, }
0- for 0 <= i0_outer < 1 | 0
	1- for 0 <= i1_outer < 1 | 0
		2- for 0 <= i0_inner < 32 | 0
			3- for 0 <= i1_inner < 32 | 0
				4- for 0 <= i2 < 320 | 0
					comp00
				4- for 0 <= i3_outer < 80 | 0
					5- for 0 <= i3_inner < 4 | 1
						comp01

<legal>

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf02.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf02"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf02 = _halide_buffer_get_host(buf02.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input03_b2[float64 * 320 * 64 * 64]
  allocate _input01_b1[float64 * 320]
  allocate _icomp00_b0[float64 * 64 * 64]
  allocate _comp01_b4[float64 * 320 * 64 * 64]
  allocate _comp00_b3[float64 * 320 * 64 * 64]
  for (c1, -2, 3) {
    for (c3, -2, 3) {
      for (c5, (-63 - min((c1*32), -63)), ((min((c1*-32), 31) + min((c1*32), -63)) + 64)) {
        for (c7, (-63 - min((c3*32), -63)), ((min((c3*-32), 31) + min((c3*32), -63)) + 64)) {
          for (c9, 0, 320) {
            buf00[(((c3*-32) - c7) + int32((int64(((c1*-32) - c5))*(int64)64)))] = ((1.000000 - (buf01[c9]*1.260000))*buf00[(((c3*-32) - c7) + int32((int64(((c1*-32) - c5))*(int64)64)))])
          }
          for (c9, 0, 80) {
            unrolled (c11, 0, 4) {
              buf02[((((c9*4) + c11) + int32((int64(((c3*-32) - c7))*(int64)320))) + int32((int64(((c1*-32) - c5))*(int64)20480)))] = (buf00[(((c3*-32) - c7) + int32((int64(((c1*-32) - c5))*(int64)64)))] + buf03[((((c9*4) + c11) + int32((int64(((c3*-32) - c7))*(int64)320))) + int32((int64(((c1*-32) - c5))*(int64)20480)))])
            }
          }
        }
      }
    }
  }
}

<legal>
Schedule number 58
Evaluation : 1.448540
Number of measurements : 3
===================================

parallelization unrolling: .*P\(\{(C[0-9],)*C0(,C[0-9])*\},L2\)U.*|.*P\(\{(C[0-9],)*C1(,C[0-9])*\},L2\)U.*
parallelization tiling: .*P\(\{(C[0-9],)*C0(,C[0-9])*\},L2\)T2\(\{(C[0-9],)*C0(,C[0-9])*\},L0,L1.*|.*P\(\{(C[0-9],)*C1(,C[0-9])*\},L2\)T2\(\{(C[0-9],)*C1(,C[0-9])*\},L0,L1.*
else
transform_ast

-----------
Matrix Transform 3x3 {comp00, } [1, 0, 0, 0, 1, 0, 0, 0, 1]
Matrix Transform 3x3 {comp01, } [1, 0, 0, 0, 1, 0, 0, 0, 1]
Matrix Transform 2x2 {comp00, comp01, } [1, 0, 0, -1]
Matrix Transform 3x3 {comp01, } [1, 0, 0, 0, 1, 0, 0, 0, -1]
Matrix Transform 2x2 {comp00, comp01, } [-1, 0, 0, 1]
Matrix Transform 3x3 {comp01, } [1, 0, 0, 0, 1, 0, 0, 0, -1]
Tiling L0 32 L1 32 { comp00, comp01, }
Unrolling L4 8 { comp01, }
0- for 0 <= i0_outer < 1 | 0
	1- for 0 <= i1_outer < 1 | 0
		2- for 0 <= i0_inner < 32 | 0
			3- for 0 <= i1_inner < 32 | 0
				4- for 0 <= i2 < 320 | 0
					comp00
				4- for 0 <= i3_outer < 40 | 0
					5- for 0 <= i3_inner < 8 | 1
						comp01

<legal>

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf02.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf02"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf02 = _halide_buffer_get_host(buf02.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input03_b2[float64 * 320 * 64 * 64]
  allocate _input01_b1[float64 * 320]
  allocate _icomp00_b0[float64 * 64 * 64]
  allocate _comp01_b4[float64 * 320 * 64 * 64]
  allocate _comp00_b3[float64 * 320 * 64 * 64]
  for (c1, -2, 3) {
    for (c3, -2, 3) {
      for (c5, (-63 - min((c1*32), -63)), ((min((c1*-32), 31) + min((c1*32), -63)) + 64)) {
        for (c7, (-63 - min((c3*32), -63)), ((min((c3*-32), 31) + min((c3*32), -63)) + 64)) {
          for (c9, 0, 320) {
            buf00[(((c3*-32) - c7) + int32((int64(((c1*-32) - c5))*(int64)64)))] = ((1.000000 - (buf01[c9]*1.260000))*buf00[(((c3*-32) - c7) + int32((int64(((c1*-32) - c5))*(int64)64)))])
          }
          for (c9, 0, 40) {
            unrolled (c11, 0, 8) {
              buf02[((((c9*8) + c11) + int32((int64(((c3*-32) - c7))*(int64)320))) + int32((int64(((c1*-32) - c5))*(int64)20480)))] = (buf00[(((c3*-32) - c7) + int32((int64(((c1*-32) - c5))*(int64)64)))] + buf03[((((c9*8) + c11) + int32((int64(((c3*-32) - c7))*(int64)320))) + int32((int64(((c1*-32) - c5))*(int64)20480)))])
            }
          }
        }
      }
    }
  }
}

<legal>
Schedule number 59
Evaluation : 1.726230
Number of measurements : 3
===================================

parallelization unrolling: .*P\(\{(C[0-9],)*C0(,C[0-9])*\},L2\)U.*|.*P\(\{(C[0-9],)*C1(,C[0-9])*\},L2\)U.*
parallelization tiling: .*P\(\{(C[0-9],)*C0(,C[0-9])*\},L2\)T2\(\{(C[0-9],)*C0(,C[0-9])*\},L0,L1.*|.*P\(\{(C[0-9],)*C1(,C[0-9])*\},L2\)T2\(\{(C[0-9],)*C1(,C[0-9])*\},L0,L1.*
else
transform_ast

-----------
Matrix Transform 3x3 {comp00, } [1, 0, 0, 0, 1, 0, 0, 0, 1]
Matrix Transform 3x3 {comp01, } [1, 0, 0, 0, 1, 0, 0, 0, 1]
Matrix Transform 2x2 {comp00, comp01, } [1, 0, 0, -1]
Matrix Transform 3x3 {comp01, } [1, 0, 0, 0, 1, 0, 0, 0, -1]
Matrix Transform 2x2 {comp00, comp01, } [-1, 0, 0, 1]
Matrix Transform 3x3 {comp01, } [1, 0, 0, 0, 1, 0, 0, 0, -1]
Tiling L0 32 L1 32 { comp00, comp01, }
Unrolling L4 16 { comp01, }
0- for 0 <= i0_outer < 1 | 0
	1- for 0 <= i1_outer < 1 | 0
		2- for 0 <= i0_inner < 32 | 0
			3- for 0 <= i1_inner < 32 | 0
				4- for 0 <= i2 < 320 | 0
					comp00
				4- for 0 <= i3_outer < 20 | 0
					5- for 0 <= i3_inner < 16 | 1
						comp01

<legal>

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf02.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf02"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf02 = _halide_buffer_get_host(buf02.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input03_b2[float64 * 320 * 64 * 64]
  allocate _input01_b1[float64 * 320]
  allocate _icomp00_b0[float64 * 64 * 64]
  allocate _comp01_b4[float64 * 320 * 64 * 64]
  allocate _comp00_b3[float64 * 320 * 64 * 64]
  for (c1, -2, 3) {
    for (c3, -2, 3) {
      for (c5, (-63 - min((c1*32), -63)), ((min((c1*-32), 31) + min((c1*32), -63)) + 64)) {
        for (c7, (-63 - min((c3*32), -63)), ((min((c3*-32), 31) + min((c3*32), -63)) + 64)) {
          for (c9, 0, 320) {
            buf00[(((c3*-32) - c7) + int32((int64(((c1*-32) - c5))*(int64)64)))] = ((1.000000 - (buf01[c9]*1.260000))*buf00[(((c3*-32) - c7) + int32((int64(((c1*-32) - c5))*(int64)64)))])
          }
          for (c9, 0, 20) {
            unrolled (c11, 0, 16) {
              buf02[((((c9*16) + c11) + int32((int64(((c3*-32) - c7))*(int64)320))) + int32((int64(((c1*-32) - c5))*(int64)20480)))] = (buf00[(((c3*-32) - c7) + int32((int64(((c1*-32) - c5))*(int64)64)))] + buf03[((((c9*16) + c11) + int32((int64(((c3*-32) - c7))*(int64)320))) + int32((int64(((c1*-32) - c5))*(int64)20480)))])
            }
          }
        }
      }
    }
  }
}

<legal>
Schedule number 60
Evaluation : 3.010190
Number of measurements : 3
===================================

parallelization unrolling: .*P\(\{(C[0-9],)*C0(,C[0-9])*\},L2\)U.*|.*P\(\{(C[0-9],)*C1(,C[0-9])*\},L2\)U.*
parallelization tiling: .*P\(\{(C[0-9],)*C0(,C[0-9])*\},L2\)T2\(\{(C[0-9],)*C0(,C[0-9])*\},L0,L1.*|.*P\(\{(C[0-9],)*C1(,C[0-9])*\},L2\)T2\(\{(C[0-9],)*C1(,C[0-9])*\},L0,L1.*
else
transform_ast

-----------
Matrix Transform 3x3 {comp00, } [1, 0, 0, 0, 1, 0, 0, 0, 1]
Matrix Transform 3x3 {comp01, } [1, 0, 0, 0, 1, 0, 0, 0, 1]
Matrix Transform 2x2 {comp00, comp01, } [1, 0, 0, -1]
Matrix Transform 3x3 {comp01, } [1, 0, 0, 0, 1, 0, 0, 0, -1]
Matrix Transform 2x2 {comp00, comp01, } [-1, 0, 0, 1]
Matrix Transform 3x3 {comp01, } [1, 0, 0, 0, 1, 0, 0, 0, -1]
Tiling L0 32 L1 32 { comp00, comp01, }
Unrolling L4 4 { comp00, }
Unrolling L4 4 { comp01, }
0- for 0 <= i0_outer < 1 | 0
	1- for 0 <= i1_outer < 1 | 0
		2- for 0 <= i0_inner < 32 | 0
			3- for 0 <= i1_inner < 32 | 0
				4- for 0 <= i2_outer < 80 | 0
					5- for 0 <= i2_inner < 4 | 1
						comp00
				4- for 0 <= i3_outer < 80 | 0
					5- for 0 <= i3_inner < 4 | 1
						comp01

<legal>

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf02.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf02"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf02 = _halide_buffer_get_host(buf02.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input03_b2[float64 * 320 * 64 * 64]
  allocate _input01_b1[float64 * 320]
  allocate _icomp00_b0[float64 * 64 * 64]
  allocate _comp01_b4[float64 * 320 * 64 * 64]
  allocate _comp00_b3[float64 * 320 * 64 * 64]
  for (c1, -2, 3) {
    for (c3, -2, 3) {
      for (c5, (-63 - min((c1*32), -63)), ((min((c1*-32), 31) + min((c1*32), -63)) + 64)) {
        for (c7, (-63 - min((c3*32), -63)), ((min((c3*-32), 31) + min((c3*32), -63)) + 64)) {
          for (c9, 0, 80) {
            unrolled (c11, 0, 4) {
              buf00[(((c3*-32) - c7) + int32((int64(((c1*-32) - c5))*(int64)64)))] = ((1.000000 - (buf01[((c9*4) + c11)]*1.260000))*buf00[(((c3*-32) - c7) + int32((int64(((c1*-32) - c5))*(int64)64)))])
            }
          }
          for (c9, 0, 80) {
            unrolled (c11, 0, 4) {
              buf02[((((c9*4) + c11) + int32((int64(((c3*-32) - c7))*(int64)320))) + int32((int64(((c1*-32) - c5))*(int64)20480)))] = (buf00[(((c3*-32) - c7) + int32((int64(((c1*-32) - c5))*(int64)64)))] + buf03[((((c9*4) + c11) + int32((int64(((c3*-32) - c7))*(int64)320))) + int32((int64(((c1*-32) - c5))*(int64)20480)))])
            }
          }
        }
      }
    }
  }
}

<legal>
Schedule number 61
Evaluation : 1.551720
Number of measurements : 3
===================================

parallelization unrolling: .*P\(\{(C[0-9],)*C0(,C[0-9])*\},L2\)U.*|.*P\(\{(C[0-9],)*C1(,C[0-9])*\},L2\)U.*
parallelization tiling: .*P\(\{(C[0-9],)*C0(,C[0-9])*\},L2\)T2\(\{(C[0-9],)*C0(,C[0-9])*\},L0,L1.*|.*P\(\{(C[0-9],)*C1(,C[0-9])*\},L2\)T2\(\{(C[0-9],)*C1(,C[0-9])*\},L0,L1.*
else
transform_ast

-----------
Matrix Transform 3x3 {comp00, } [1, 0, 0, 0, 1, 0, 0, 0, 1]
Matrix Transform 3x3 {comp01, } [1, 0, 0, 0, 1, 0, 0, 0, 1]
Matrix Transform 2x2 {comp00, comp01, } [1, 0, 0, -1]
Matrix Transform 3x3 {comp01, } [1, 0, 0, 0, 1, 0, 0, 0, -1]
Matrix Transform 2x2 {comp00, comp01, } [-1, 0, 0, 1]
Matrix Transform 3x3 {comp01, } [1, 0, 0, 0, 1, 0, 0, 0, -1]
Tiling L0 32 L1 32 { comp00, comp01, }
Unrolling L4 4 { comp00, }
Unrolling L4 8 { comp01, }
0- for 0 <= i0_outer < 1 | 0
	1- for 0 <= i1_outer < 1 | 0
		2- for 0 <= i0_inner < 32 | 0
			3- for 0 <= i1_inner < 32 | 0
				4- for 0 <= i2_outer < 80 | 0
					5- for 0 <= i2_inner < 4 | 1
						comp00
				4- for 0 <= i3_outer < 40 | 0
					5- for 0 <= i3_inner < 8 | 1
						comp01

<legal>

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf02.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf02"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf02 = _halide_buffer_get_host(buf02.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input03_b2[float64 * 320 * 64 * 64]
  allocate _input01_b1[float64 * 320]
  allocate _icomp00_b0[float64 * 64 * 64]
  allocate _comp01_b4[float64 * 320 * 64 * 64]
  allocate _comp00_b3[float64 * 320 * 64 * 64]
  for (c1, -2, 3) {
    for (c3, -2, 3) {
      for (c5, (-63 - min((c1*32), -63)), ((min((c1*-32), 31) + min((c1*32), -63)) + 64)) {
        for (c7, (-63 - min((c3*32), -63)), ((min((c3*-32), 31) + min((c3*32), -63)) + 64)) {
          for (c9, 0, 80) {
            unrolled (c11, 0, 4) {
              buf00[(((c3*-32) - c7) + int32((int64(((c1*-32) - c5))*(int64)64)))] = ((1.000000 - (buf01[((c9*4) + c11)]*1.260000))*buf00[(((c3*-32) - c7) + int32((int64(((c1*-32) - c5))*(int64)64)))])
            }
          }
          for (c9, 0, 40) {
            unrolled (c11, 0, 8) {
              buf02[((((c9*8) + c11) + int32((int64(((c3*-32) - c7))*(int64)320))) + int32((int64(((c1*-32) - c5))*(int64)20480)))] = (buf00[(((c3*-32) - c7) + int32((int64(((c1*-32) - c5))*(int64)64)))] + buf03[((((c9*8) + c11) + int32((int64(((c3*-32) - c7))*(int64)320))) + int32((int64(((c1*-32) - c5))*(int64)20480)))])
            }
          }
        }
      }
    }
  }
}

<legal>
Schedule number 62
Evaluation : 1.586420
Number of measurements : 3
===================================

parallelization unrolling: .*P\(\{(C[0-9],)*C0(,C[0-9])*\},L2\)U.*|.*P\(\{(C[0-9],)*C1(,C[0-9])*\},L2\)U.*
parallelization tiling: .*P\(\{(C[0-9],)*C0(,C[0-9])*\},L2\)T2\(\{(C[0-9],)*C0(,C[0-9])*\},L0,L1.*|.*P\(\{(C[0-9],)*C1(,C[0-9])*\},L2\)T2\(\{(C[0-9],)*C1(,C[0-9])*\},L0,L1.*
else
transform_ast

-----------
Matrix Transform 3x3 {comp00, } [1, 0, 0, 0, 1, 0, 0, 0, 1]
Matrix Transform 3x3 {comp01, } [1, 0, 0, 0, 1, 0, 0, 0, 1]
Matrix Transform 2x2 {comp00, comp01, } [1, 0, 0, -1]
Matrix Transform 3x3 {comp01, } [1, 0, 0, 0, 1, 0, 0, 0, -1]
Matrix Transform 2x2 {comp00, comp01, } [-1, 0, 0, 1]
Matrix Transform 3x3 {comp01, } [1, 0, 0, 0, 1, 0, 0, 0, -1]
Tiling L0 32 L1 32 { comp00, comp01, }
Unrolling L4 4 { comp00, }
Unrolling L4 16 { comp01, }
0- for 0 <= i0_outer < 1 | 0
	1- for 0 <= i1_outer < 1 | 0
		2- for 0 <= i0_inner < 32 | 0
			3- for 0 <= i1_inner < 32 | 0
				4- for 0 <= i2_outer < 80 | 0
					5- for 0 <= i2_inner < 4 | 1
						comp00
				4- for 0 <= i3_outer < 20 | 0
					5- for 0 <= i3_inner < 16 | 1
						comp01

<legal>

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf02.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf02"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf02 = _halide_buffer_get_host(buf02.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input03_b2[float64 * 320 * 64 * 64]
  allocate _input01_b1[float64 * 320]
  allocate _icomp00_b0[float64 * 64 * 64]
  allocate _comp01_b4[float64 * 320 * 64 * 64]
  allocate _comp00_b3[float64 * 320 * 64 * 64]
  for (c1, -2, 3) {
    for (c3, -2, 3) {
      for (c5, (-63 - min((c1*32), -63)), ((min((c1*-32), 31) + min((c1*32), -63)) + 64)) {
        for (c7, (-63 - min((c3*32), -63)), ((min((c3*-32), 31) + min((c3*32), -63)) + 64)) {
          for (c9, 0, 80) {
            unrolled (c11, 0, 4) {
              buf00[(((c3*-32) - c7) + int32((int64(((c1*-32) - c5))*(int64)64)))] = ((1.000000 - (buf01[((c9*4) + c11)]*1.260000))*buf00[(((c3*-32) - c7) + int32((int64(((c1*-32) - c5))*(int64)64)))])
            }
          }
          for (c9, 0, 20) {
            unrolled (c11, 0, 16) {
              buf02[((((c9*16) + c11) + int32((int64(((c3*-32) - c7))*(int64)320))) + int32((int64(((c1*-32) - c5))*(int64)20480)))] = (buf00[(((c3*-32) - c7) + int32((int64(((c1*-32) - c5))*(int64)64)))] + buf03[((((c9*16) + c11) + int32((int64(((c3*-32) - c7))*(int64)320))) + int32((int64(((c1*-32) - c5))*(int64)20480)))])
            }
          }
        }
      }
    }
  }
}

<legal>
Schedule number 63
Evaluation : 1.463340
Number of measurements : 3
===================================

parallelization unrolling: .*P\(\{(C[0-9],)*C0(,C[0-9])*\},L2\)U.*|.*P\(\{(C[0-9],)*C1(,C[0-9])*\},L2\)U.*
parallelization tiling: .*P\(\{(C[0-9],)*C0(,C[0-9])*\},L2\)T2\(\{(C[0-9],)*C0(,C[0-9])*\},L0,L1.*|.*P\(\{(C[0-9],)*C1(,C[0-9])*\},L2\)T2\(\{(C[0-9],)*C1(,C[0-9])*\},L0,L1.*
else
transform_ast

-----------
Matrix Transform 3x3 {comp00, } [1, 0, 0, 0, 1, 0, 0, 0, 1]
Matrix Transform 3x3 {comp01, } [1, 0, 0, 0, 1, 0, 0, 0, 1]
Matrix Transform 2x2 {comp00, comp01, } [1, 0, 0, -1]
Matrix Transform 3x3 {comp01, } [1, 0, 0, 0, 1, 0, 0, 0, -1]
Matrix Transform 2x2 {comp00, comp01, } [-1, 0, 0, 1]
Matrix Transform 3x3 {comp01, } [1, 0, 0, 0, 1, 0, 0, 0, -1]
Tiling L0 32 L1 32 { comp00, comp01, }
Unrolling L4 16 { comp00, }
Unrolling L4 4 { comp01, }
0- for 0 <= i0_outer < 1 | 0
	1- for 0 <= i1_outer < 1 | 0
		2- for 0 <= i0_inner < 32 | 0
			3- for 0 <= i1_inner < 32 | 0
				4- for 0 <= i2_outer < 20 | 0
					5- for 0 <= i2_inner < 16 | 1
						comp00
				4- for 0 <= i3_outer < 80 | 0
					5- for 0 <= i3_inner < 4 | 1
						comp01

<legal>

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf02.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf02"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf02 = _halide_buffer_get_host(buf02.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input03_b2[float64 * 320 * 64 * 64]
  allocate _input01_b1[float64 * 320]
  allocate _icomp00_b0[float64 * 64 * 64]
  allocate _comp01_b4[float64 * 320 * 64 * 64]
  allocate _comp00_b3[float64 * 320 * 64 * 64]
  for (c1, -2, 3) {
    for (c3, -2, 3) {
      for (c5, (-63 - min((c1*32), -63)), ((min((c1*-32), 31) + min((c1*32), -63)) + 64)) {
        for (c7, (-63 - min((c3*32), -63)), ((min((c3*-32), 31) + min((c3*32), -63)) + 64)) {
          for (c9, 0, 20) {
            unrolled (c11, 0, 16) {
              buf00[(((c3*-32) - c7) + int32((int64(((c1*-32) - c5))*(int64)64)))] = ((1.000000 - (buf01[((c9*16) + c11)]*1.260000))*buf00[(((c3*-32) - c7) + int32((int64(((c1*-32) - c5))*(int64)64)))])
            }
          }
          for (c9, 0, 80) {
            unrolled (c11, 0, 4) {
              buf02[((((c9*4) + c11) + int32((int64(((c3*-32) - c7))*(int64)320))) + int32((int64(((c1*-32) - c5))*(int64)20480)))] = (buf00[(((c3*-32) - c7) + int32((int64(((c1*-32) - c5))*(int64)64)))] + buf03[((((c9*4) + c11) + int32((int64(((c3*-32) - c7))*(int64)320))) + int32((int64(((c1*-32) - c5))*(int64)20480)))])
            }
          }
        }
      }
    }
  }
}

<legal>
Schedule number 64
Evaluation : 1.388870
Number of measurements : 3
===================================

parallelization unrolling: .*P\(\{(C[0-9],)*C0(,C[0-9])*\},L2\)U.*|.*P\(\{(C[0-9],)*C1(,C[0-9])*\},L2\)U.*
parallelization tiling: .*P\(\{(C[0-9],)*C0(,C[0-9])*\},L2\)T2\(\{(C[0-9],)*C0(,C[0-9])*\},L0,L1.*|.*P\(\{(C[0-9],)*C1(,C[0-9])*\},L2\)T2\(\{(C[0-9],)*C1(,C[0-9])*\},L0,L1.*
else
transform_ast

-----------
Matrix Transform 3x3 {comp00, } [1, 0, 0, 0, 1, 0, 0, 0, 1]
Matrix Transform 3x3 {comp01, } [1, 0, 0, 0, 1, 0, 0, 0, 1]
Matrix Transform 2x2 {comp00, comp01, } [1, 0, 0, -1]
Matrix Transform 3x3 {comp01, } [1, 0, 0, 0, 1, 0, 0, 0, -1]
Matrix Transform 2x2 {comp00, comp01, } [-1, 0, 0, 1]
Matrix Transform 3x3 {comp01, } [1, 0, 0, 0, 1, 0, 0, 0, -1]
Tiling L0 32 L1 32 { comp00, comp01, }
Unrolling L4 16 { comp00, }
Unrolling L4 8 { comp01, }
0- for 0 <= i0_outer < 1 | 0
	1- for 0 <= i1_outer < 1 | 0
		2- for 0 <= i0_inner < 32 | 0
			3- for 0 <= i1_inner < 32 | 0
				4- for 0 <= i2_outer < 20 | 0
					5- for 0 <= i2_inner < 16 | 1
						comp00
				4- for 0 <= i3_outer < 40 | 0
					5- for 0 <= i3_inner < 8 | 1
						comp01

<legal>

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf02.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf02"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf02 = _halide_buffer_get_host(buf02.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input03_b2[float64 * 320 * 64 * 64]
  allocate _input01_b1[float64 * 320]
  allocate _icomp00_b0[float64 * 64 * 64]
  allocate _comp01_b4[float64 * 320 * 64 * 64]
  allocate _comp00_b3[float64 * 320 * 64 * 64]
  for (c1, -2, 3) {
    for (c3, -2, 3) {
      for (c5, (-63 - min((c1*32), -63)), ((min((c1*-32), 31) + min((c1*32), -63)) + 64)) {
        for (c7, (-63 - min((c3*32), -63)), ((min((c3*-32), 31) + min((c3*32), -63)) + 64)) {
          for (c9, 0, 20) {
            unrolled (c11, 0, 16) {
              buf00[(((c3*-32) - c7) + int32((int64(((c1*-32) - c5))*(int64)64)))] = ((1.000000 - (buf01[((c9*16) + c11)]*1.260000))*buf00[(((c3*-32) - c7) + int32((int64(((c1*-32) - c5))*(int64)64)))])
            }
          }
          for (c9, 0, 40) {
            unrolled (c11, 0, 8) {
              buf02[((((c9*8) + c11) + int32((int64(((c3*-32) - c7))*(int64)320))) + int32((int64(((c1*-32) - c5))*(int64)20480)))] = (buf00[(((c3*-32) - c7) + int32((int64(((c1*-32) - c5))*(int64)64)))] + buf03[((((c9*8) + c11) + int32((int64(((c3*-32) - c7))*(int64)320))) + int32((int64(((c1*-32) - c5))*(int64)20480)))])
            }
          }
        }
      }
    }
  }
}

<legal>
Schedule number 65
Evaluation : 1.759060
Number of measurements : 3
===================================

parallelization unrolling: .*P\(\{(C[0-9],)*C0(,C[0-9])*\},L2\)U.*|.*P\(\{(C[0-9],)*C1(,C[0-9])*\},L2\)U.*
parallelization tiling: .*P\(\{(C[0-9],)*C0(,C[0-9])*\},L2\)T2\(\{(C[0-9],)*C0(,C[0-9])*\},L0,L1.*|.*P\(\{(C[0-9],)*C1(,C[0-9])*\},L2\)T2\(\{(C[0-9],)*C1(,C[0-9])*\},L0,L1.*
else
transform_ast

-----------
Matrix Transform 3x3 {comp00, } [1, 0, 0, 0, 1, 0, 0, 0, 1]
Matrix Transform 3x3 {comp01, } [1, 0, 0, 0, 1, 0, 0, 0, 1]
Matrix Transform 2x2 {comp00, comp01, } [1, 0, 0, -1]
Matrix Transform 3x3 {comp01, } [1, 0, 0, 0, 1, 0, 0, 0, -1]
Matrix Transform 2x2 {comp00, comp01, } [-1, 0, 0, 1]
Matrix Transform 3x3 {comp01, } [1, 0, 0, 0, 1, 0, 0, 0, -1]
Tiling L0 32 L1 32 { comp00, comp01, }
Unrolling L4 16 { comp00, }
Unrolling L4 16 { comp01, }
0- for 0 <= i0_outer < 1 | 0
	1- for 0 <= i1_outer < 1 | 0
		2- for 0 <= i0_inner < 32 | 0
			3- for 0 <= i1_inner < 32 | 0
				4- for 0 <= i2_outer < 20 | 0
					5- for 0 <= i2_inner < 16 | 1
						comp00
				4- for 0 <= i3_outer < 20 | 0
					5- for 0 <= i3_inner < 16 | 1
						comp01

<legal>

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf02.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf02"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf02 = _halide_buffer_get_host(buf02.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input03_b2[float64 * 320 * 64 * 64]
  allocate _input01_b1[float64 * 320]
  allocate _icomp00_b0[float64 * 64 * 64]
  allocate _comp01_b4[float64 * 320 * 64 * 64]
  allocate _comp00_b3[float64 * 320 * 64 * 64]
  for (c1, -2, 3) {
    for (c3, -2, 3) {
      for (c5, (-63 - min((c1*32), -63)), ((min((c1*-32), 31) + min((c1*32), -63)) + 64)) {
        for (c7, (-63 - min((c3*32), -63)), ((min((c3*-32), 31) + min((c3*32), -63)) + 64)) {
          for (c9, 0, 20) {
            unrolled (c11, 0, 16) {
              buf00[(((c3*-32) - c7) + int32((int64(((c1*-32) - c5))*(int64)64)))] = ((1.000000 - (buf01[((c9*16) + c11)]*1.260000))*buf00[(((c3*-32) - c7) + int32((int64(((c1*-32) - c5))*(int64)64)))])
            }
          }
          for (c9, 0, 20) {
            unrolled (c11, 0, 16) {
              buf02[((((c9*16) + c11) + int32((int64(((c3*-32) - c7))*(int64)320))) + int32((int64(((c1*-32) - c5))*(int64)20480)))] = (buf00[(((c3*-32) - c7) + int32((int64(((c1*-32) - c5))*(int64)64)))] + buf03[((((c9*16) + c11) + int32((int64(((c3*-32) - c7))*(int64)320))) + int32((int64(((c1*-32) - c5))*(int64)20480)))])
            }
          }
        }
      }
    }
  }
}

<legal>
Schedule number 66
Evaluation : 1.826210
Number of measurements : 3
===================================

parallelization unrolling: .*P\(\{(C[0-9],)*C0(,C[0-9])*\},L2\)U.*|.*P\(\{(C[0-9],)*C1(,C[0-9])*\},L2\)U.*
parallelization tiling: .*P\(\{(C[0-9],)*C0(,C[0-9])*\},L2\)T2\(\{(C[0-9],)*C0(,C[0-9])*\},L0,L1.*|.*P\(\{(C[0-9],)*C1(,C[0-9])*\},L2\)T2\(\{(C[0-9],)*C1(,C[0-9])*\},L0,L1.*
else
transform_ast

-----------
Matrix Transform 3x3 {comp00, } [1, 0, 0, 0, 1, 0, 0, 0, 1]
Matrix Transform 3x3 {comp01, } [1, 0, 0, 0, 1, 0, 0, 0, 1]
Matrix Transform 2x2 {comp00, comp01, } [1, 0, 0, -1]
Matrix Transform 3x3 {comp01, } [1, 0, 0, 0, 1, 0, 0, 0, -1]
Matrix Transform 2x2 {comp00, comp01, } [-1, 0, 0, 1]
Parallelize L0 { comp00, comp01, }
0- for -63 <= i0 < 1 | 0 | P
	1- for -63 <= i1 < 1 | 0
		2- for 0 <= i2 < 320 | 0
			comp00
		2- for -319 <= i3 < 1 | 0
			comp01

<legal>

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf02.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf02"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf02 = _halide_buffer_get_host(buf02.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input03_b2[float64 * 320 * 64 * 64]
  allocate _input01_b1[float64 * 320]
  allocate _icomp00_b0[float64 * 64 * 64]
  allocate _comp01_b4[float64 * 320 * 64 * 64]
  allocate _comp00_b3[float64 * 320 * 64 * 64]
  parallel (c1, -63, 64) {
    for (c3, -63, 64) {
      for (c5, 0, 320) {
        buf00[(int32((int64((0 - c1))*(int64)64)) - c3)] = ((1.000000 - (buf01[c5]*1.260000))*buf00[(int32((int64((0 - c1))*(int64)64)) - c3)])
      }
      for (c5, -319, 320) {
        buf02[((int32((int64((0 - c3))*(int64)320)) - c5) + int32((int64((0 - c1))*(int64)20480)))] = (buf00[(int32((int64((0 - c1))*(int64)64)) - c3)] + buf03[((int32((int64((0 - c3))*(int64)320)) - c5) + int32((int64((0 - c1))*(int64)20480)))])
      }
    }
  }
}

<legal>
Schedule number 67
Evaluation : 1.470640
Number of measurements : 3
===================================

parallelization unrolling: .*P\(\{(C[0-9],)*C0(,C[0-9])*\},L2\)U.*|.*P\(\{(C[0-9],)*C1(,C[0-9])*\},L2\)U.*
parallelization tiling: .*P\(\{(C[0-9],)*C0(,C[0-9])*\},L2\)T2\(\{(C[0-9],)*C0(,C[0-9])*\},L0,L1.*|.*P\(\{(C[0-9],)*C1(,C[0-9])*\},L2\)T2\(\{(C[0-9],)*C1(,C[0-9])*\},L0,L1.*
else
transform_ast

-----------
Matrix Transform 3x3 {comp00, } [1, 0, 0, 0, 1, 0, 0, 0, 1]
Matrix Transform 3x3 {comp01, } [1, 0, 0, 0, 1, 0, 0, 0, 1]
Matrix Transform 2x2 {comp00, comp01, } [1, 0, 0, -1]
Matrix Transform 3x3 {comp01, } [1, 0, 0, 0, 1, 0, 0, 0, -1]
Matrix Transform 2x2 {comp00, comp01, } [-1, 0, 0, 1]
Parallelize L1 { comp00, comp01, }
0- for -63 <= i0 < 1 | 0
	1- for -63 <= i1 < 1 | 0 | P
		2- for 0 <= i2 < 320 | 0
			comp00
		2- for -319 <= i3 < 1 | 0
			comp01

<legal>

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf02.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf02"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf02 = _halide_buffer_get_host(buf02.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input03_b2[float64 * 320 * 64 * 64]
  allocate _input01_b1[float64 * 320]
  allocate _icomp00_b0[float64 * 64 * 64]
  allocate _comp01_b4[float64 * 320 * 64 * 64]
  allocate _comp00_b3[float64 * 320 * 64 * 64]
  for (c1, -63, 64) {
    parallel (c3, -63, 64) {
      for (c5, 0, 320) {
        buf00[(int32((int64((0 - c1))*(int64)64)) - c3)] = ((1.000000 - (buf01[c5]*1.260000))*buf00[(int32((int64((0 - c1))*(int64)64)) - c3)])
      }
      for (c5, -319, 320) {
        buf02[((int32((int64((0 - c3))*(int64)320)) - c5) + int32((int64((0 - c1))*(int64)20480)))] = (buf00[(int32((int64((0 - c1))*(int64)64)) - c3)] + buf03[((int32((int64((0 - c3))*(int64)320)) - c5) + int32((int64((0 - c1))*(int64)20480)))])
      }
    }
  }
}

<legal>
Schedule number 68
Evaluation : 1.456630
Number of measurements : 3
===================================

parallelization unrolling: .*P\(\{(C[0-9],)*C0(,C[0-9])*\},L2\)U.*|.*P\(\{(C[0-9],)*C1(,C[0-9])*\},L2\)U.*
parallelization tiling: .*P\(\{(C[0-9],)*C0(,C[0-9])*\},L2\)T2\(\{(C[0-9],)*C0(,C[0-9])*\},L0,L1.*|.*P\(\{(C[0-9],)*C1(,C[0-9])*\},L2\)T2\(\{(C[0-9],)*C1(,C[0-9])*\},L0,L1.*
else
transform_ast

-----------
Matrix Transform 3x3 {comp00, } [1, 0, 0, 0, 1, 0, 0, 0, 1]
Matrix Transform 3x3 {comp01, } [1, 0, 0, 0, 1, 0, 0, 0, 1]
Matrix Transform 2x2 {comp00, comp01, } [1, 0, 0, -1]
Matrix Transform 3x3 {comp01, } [1, 0, 0, 0, 1, 0, 0, 0, -1]
Matrix Transform 2x2 {comp00, comp01, } [-1, 0, 0, 1]
Parallelize L2 { comp01, }
0- for -63 <= i0 < 1 | 0
	1- for -63 <= i1 < 1 | 0
		2- for 0 <= i2 < 320 | 0
			comp00
		2- for -319 <= i3 < 1 | 0 | P
			comp01

<legal>
set to default

<legal>
Schedule number 69
Evaluation : 0.000000
Number of measurements : 1
===================================

parallelization unrolling: .*P\(\{(C[0-9],)*C0(,C[0-9])*\},L2\)U.*|.*P\(\{(C[0-9],)*C1(,C[0-9])*\},L2\)U.*
parallelization tiling: .*P\(\{(C[0-9],)*C0(,C[0-9])*\},L2\)T2\(\{(C[0-9],)*C0(,C[0-9])*\},L0,L1.*|.*P\(\{(C[0-9],)*C1(,C[0-9])*\},L2\)T2\(\{(C[0-9],)*C1(,C[0-9])*\},L0,L1.*
if

-----------
Matrix Transform 3x3 {comp00, } [1, 0, 0, 0, 1, 0, 0, 0, 1]
Matrix Transform 3x3 {comp01, } [1, 0, 0, 0, 1, 0, 0, 0, 1]
Matrix Transform 2x2 {comp00, comp01, } [1, 0, 0, -1]
Matrix Transform 3x3 {comp01, } [1, 0, 0, 0, 1, 0, 0, 0, -1]
Matrix Transform 2x2 {comp00, comp01, } [-1, 0, 0, 1]
Parallelize L2 { comp01, }
Tiling L0 32 L1 32 { comp00, comp01, }
0- for -63 <= i0 < 1 | 0
	1- for -63 <= i1 < 1 | 0
		2- for 0 <= i2 < 320 | 0
			comp00
		2- for -319 <= i3 < 1 | 0 | P
			comp01

<Schedule pruned>
parallelization unrolling: .*P\(\{(C[0-9],)*C0(,C[0-9])*\},L2\)U.*|.*P\(\{(C[0-9],)*C1(,C[0-9])*\},L2\)U.*
if

-----------
Matrix Transform 3x3 {comp00, } [1, 0, 0, 0, 1, 0, 0, 0, 1]
Matrix Transform 3x3 {comp01, } [1, 0, 0, 0, 1, 0, 0, 0, 1]
Matrix Transform 2x2 {comp00, comp01, } [1, 0, 0, -1]
Matrix Transform 3x3 {comp01, } [1, 0, 0, 0, 1, 0, 0, 0, -1]
Matrix Transform 2x2 {comp00, comp01, } [-1, 0, 0, 1]
Parallelize L2 { comp01, }
Unrolling L2 4 { comp00, }
0- for -63 <= i0 < 1 | 0
	1- for -63 <= i1 < 1 | 0
		2- for 0 <= i2 < 320 | 0
			comp00
		2- for -319 <= i3 < 1 | 0 | P
			comp01

<Schedule pruned>
parallelization unrolling: .*P\(\{(C[0-9],)*C0(,C[0-9])*\},L2\)U.*|.*P\(\{(C[0-9],)*C1(,C[0-9])*\},L2\)U.*
if

-----------
Matrix Transform 3x3 {comp00, } [1, 0, 0, 0, 1, 0, 0, 0, 1]
Matrix Transform 3x3 {comp01, } [1, 0, 0, 0, 1, 0, 0, 0, 1]
Matrix Transform 2x2 {comp00, comp01, } [1, 0, 0, -1]
Matrix Transform 3x3 {comp01, } [1, 0, 0, 0, 1, 0, 0, 0, -1]
Matrix Transform 2x2 {comp00, comp01, } [-1, 0, 0, 1]
Parallelize L2 { comp01, }
Unrolling L2 8 { comp00, }
0- for -63 <= i0 < 1 | 0
	1- for -63 <= i1 < 1 | 0
		2- for 0 <= i2 < 320 | 0
			comp00
		2- for -319 <= i3 < 1 | 0 | P
			comp01

<Schedule pruned>
parallelization unrolling: .*P\(\{(C[0-9],)*C0(,C[0-9])*\},L2\)U.*|.*P\(\{(C[0-9],)*C1(,C[0-9])*\},L2\)U.*
if

-----------
Matrix Transform 3x3 {comp00, } [1, 0, 0, 0, 1, 0, 0, 0, 1]
Matrix Transform 3x3 {comp01, } [1, 0, 0, 0, 1, 0, 0, 0, 1]
Matrix Transform 2x2 {comp00, comp01, } [1, 0, 0, -1]
Matrix Transform 3x3 {comp01, } [1, 0, 0, 0, 1, 0, 0, 0, -1]
Matrix Transform 2x2 {comp00, comp01, } [-1, 0, 0, 1]
Parallelize L2 { comp01, }
Unrolling L2 16 { comp00, }
0- for -63 <= i0 < 1 | 0
	1- for -63 <= i1 < 1 | 0
		2- for 0 <= i2 < 320 | 0
			comp00
		2- for -319 <= i3 < 1 | 0 | P
			comp01

<Schedule pruned>
parallelization unrolling: .*P\(\{(C[0-9],)*C0(,C[0-9])*\},L2\)U.*|.*P\(\{(C[0-9],)*C1(,C[0-9])*\},L2\)U.*
parallelization tiling: .*P\(\{(C[0-9],)*C0(,C[0-9])*\},L2\)T2\(\{(C[0-9],)*C0(,C[0-9])*\},L0,L1.*|.*P\(\{(C[0-9],)*C1(,C[0-9])*\},L2\)T2\(\{(C[0-9],)*C1(,C[0-9])*\},L0,L1.*
else
transform_ast

-----------
Matrix Transform 3x3 {comp00, } [1, 0, 0, 0, 1, 0, 0, 0, 1]
Matrix Transform 3x3 {comp01, } [1, 0, 0, 0, 1, 0, 0, 0, 1]
Matrix Transform 2x2 {comp00, comp01, } [1, 0, 0, -1]
Matrix Transform 3x3 {comp01, } [1, 0, 0, 0, 1, 0, 0, 0, -1]
Matrix Transform 2x2 {comp00, comp01, } [-1, 0, 0, 1]
Tiling L0 32 L1 32 { comp00, comp01, }
0- for 0 <= i0_outer < 1 | 0
	1- for 0 <= i1_outer < 1 | 0
		2- for 0 <= i0_inner < 32 | 0
			3- for 0 <= i1_inner < 32 | 0
				4- for 0 <= i2 < 320 | 0
					comp00
				4- for -319 <= i3 < 1 | 0
					comp01

<legal>

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf02.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf02"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf02 = _halide_buffer_get_host(buf02.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input03_b2[float64 * 320 * 64 * 64]
  allocate _input01_b1[float64 * 320]
  allocate _icomp00_b0[float64 * 64 * 64]
  allocate _comp01_b4[float64 * 320 * 64 * 64]
  allocate _comp00_b3[float64 * 320 * 64 * 64]
  for (c1, -2, 3) {
    for (c3, -2, 3) {
      for (c5, (-63 - min((c1*32), -63)), ((min((c1*-32), 31) + min((c1*32), -63)) + 64)) {
        for (c7, (-63 - min((c3*32), -63)), ((min((c3*-32), 31) + min((c3*32), -63)) + 64)) {
          for (c9, 0, 320) {
            buf00[(((c3*-32) - c7) + int32((int64(((c1*-32) - c5))*(int64)64)))] = ((1.000000 - (buf01[c9]*1.260000))*buf00[(((c3*-32) - c7) + int32((int64(((c1*-32) - c5))*(int64)64)))])
          }
          for (c9, -319, 320) {
            buf02[((int32((int64(((c3*-32) - c7))*(int64)320)) - c9) + int32((int64(((c1*-32) - c5))*(int64)20480)))] = (buf00[(((c3*-32) - c7) + int32((int64(((c1*-32) - c5))*(int64)64)))] + buf03[((int32((int64(((c3*-32) - c7))*(int64)320)) - c9) + int32((int64(((c1*-32) - c5))*(int64)20480)))])
          }
        }
      }
    }
  }
}

<legal>
Schedule number 70
Evaluation : 1.478980
Number of measurements : 3
===================================

parallelization unrolling: .*P\(\{(C[0-9],)*C0(,C[0-9])*\},L2\)U.*|.*P\(\{(C[0-9],)*C1(,C[0-9])*\},L2\)U.*
parallelization tiling: .*P\(\{(C[0-9],)*C0(,C[0-9])*\},L2\)T2\(\{(C[0-9],)*C0(,C[0-9])*\},L0,L1.*|.*P\(\{(C[0-9],)*C1(,C[0-9])*\},L2\)T2\(\{(C[0-9],)*C1(,C[0-9])*\},L0,L1.*
else
transform_ast

-----------
Matrix Transform 3x3 {comp00, } [1, 0, 0, 0, 1, 0, 0, 0, 1]
Matrix Transform 3x3 {comp01, } [1, 0, 0, 0, 1, 0, 0, 0, 1]
Matrix Transform 2x2 {comp00, comp01, } [1, 0, 0, -1]
Matrix Transform 3x3 {comp01, } [1, 0, 0, 0, 1, 0, 0, 0, -1]
Matrix Transform 2x2 {comp00, comp01, } [-1, 0, 0, 1]
Unrolling L2 4 { comp00, }
0- for -63 <= i0 < 1 | 0
	1- for -63 <= i1 < 1 | 0
		2- for 0 <= i2_outer < 80 | 0
			3- for 0 <= i2_inner < 4 | 1
				comp00
		2- for -319 <= i3 < 1 | 0
			comp01

<legal>

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf02.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf02"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf02 = _halide_buffer_get_host(buf02.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input03_b2[float64 * 320 * 64 * 64]
  allocate _input01_b1[float64 * 320]
  allocate _icomp00_b0[float64 * 64 * 64]
  allocate _comp01_b4[float64 * 320 * 64 * 64]
  allocate _comp00_b3[float64 * 320 * 64 * 64]
  for (c1, -63, 64) {
    for (c3, -63, 64) {
      for (c5, 0, 80) {
        unrolled (c7, 0, 4) {
          buf00[(int32((int64((0 - c1))*(int64)64)) - c3)] = ((1.000000 - (buf01[((c5*4) + c7)]*1.260000))*buf00[(int32((int64((0 - c1))*(int64)64)) - c3)])
        }
      }
      for (c5, -319, 320) {
        buf02[((int32((int64((0 - c3))*(int64)320)) - c5) + int32((int64((0 - c1))*(int64)20480)))] = (buf00[(int32((int64((0 - c1))*(int64)64)) - c3)] + buf03[((int32((int64((0 - c3))*(int64)320)) - c5) + int32((int64((0 - c1))*(int64)20480)))])
      }
    }
  }
}

<legal>
Schedule number 71
Evaluation : 1.547310
Number of measurements : 3
===================================

parallelization unrolling: .*P\(\{(C[0-9],)*C0(,C[0-9])*\},L2\)U.*|.*P\(\{(C[0-9],)*C1(,C[0-9])*\},L2\)U.*
parallelization tiling: .*P\(\{(C[0-9],)*C0(,C[0-9])*\},L2\)T2\(\{(C[0-9],)*C0(,C[0-9])*\},L0,L1.*|.*P\(\{(C[0-9],)*C1(,C[0-9])*\},L2\)T2\(\{(C[0-9],)*C1(,C[0-9])*\},L0,L1.*
else
transform_ast

-----------
Matrix Transform 3x3 {comp00, } [1, 0, 0, 0, 1, 0, 0, 0, 1]
Matrix Transform 3x3 {comp01, } [1, 0, 0, 0, 1, 0, 0, 0, 1]
Matrix Transform 2x2 {comp00, comp01, } [1, 0, 0, -1]
Matrix Transform 3x3 {comp01, } [1, 0, 0, 0, 1, 0, 0, 0, -1]
Matrix Transform 2x2 {comp00, comp01, } [-1, 0, 0, 1]
Unrolling L2 8 { comp00, }
0- for -63 <= i0 < 1 | 0
	1- for -63 <= i1 < 1 | 0
		2- for 0 <= i2_outer < 40 | 0
			3- for 0 <= i2_inner < 8 | 1
				comp00
		2- for -319 <= i3 < 1 | 0
			comp01

<legal>

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf02.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf02"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf02 = _halide_buffer_get_host(buf02.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input03_b2[float64 * 320 * 64 * 64]
  allocate _input01_b1[float64 * 320]
  allocate _icomp00_b0[float64 * 64 * 64]
  allocate _comp01_b4[float64 * 320 * 64 * 64]
  allocate _comp00_b3[float64 * 320 * 64 * 64]
  for (c1, -63, 64) {
    for (c3, -63, 64) {
      for (c5, 0, 40) {
        unrolled (c7, 0, 8) {
          buf00[(int32((int64((0 - c1))*(int64)64)) - c3)] = ((1.000000 - (buf01[((c5*8) + c7)]*1.260000))*buf00[(int32((int64((0 - c1))*(int64)64)) - c3)])
        }
      }
      for (c5, -319, 320) {
        buf02[((int32((int64((0 - c3))*(int64)320)) - c5) + int32((int64((0 - c1))*(int64)20480)))] = (buf00[(int32((int64((0 - c1))*(int64)64)) - c3)] + buf03[((int32((int64((0 - c3))*(int64)320)) - c5) + int32((int64((0 - c1))*(int64)20480)))])
      }
    }
  }
}

<legal>
Schedule number 72
Evaluation : 1.406840
Number of measurements : 3
===================================

parallelization unrolling: .*P\(\{(C[0-9],)*C0(,C[0-9])*\},L2\)U.*|.*P\(\{(C[0-9],)*C1(,C[0-9])*\},L2\)U.*
parallelization tiling: .*P\(\{(C[0-9],)*C0(,C[0-9])*\},L2\)T2\(\{(C[0-9],)*C0(,C[0-9])*\},L0,L1.*|.*P\(\{(C[0-9],)*C1(,C[0-9])*\},L2\)T2\(\{(C[0-9],)*C1(,C[0-9])*\},L0,L1.*
else
transform_ast

-----------
Matrix Transform 3x3 {comp00, } [1, 0, 0, 0, 1, 0, 0, 0, 1]
Matrix Transform 3x3 {comp01, } [1, 0, 0, 0, 1, 0, 0, 0, 1]
Matrix Transform 2x2 {comp00, comp01, } [1, 0, 0, -1]
Matrix Transform 3x3 {comp01, } [1, 0, 0, 0, 1, 0, 0, 0, -1]
Matrix Transform 2x2 {comp00, comp01, } [-1, 0, 0, 1]
Unrolling L2 16 { comp00, }
0- for -63 <= i0 < 1 | 0
	1- for -63 <= i1 < 1 | 0
		2- for 0 <= i2_outer < 20 | 0
			3- for 0 <= i2_inner < 16 | 1
				comp00
		2- for -319 <= i3 < 1 | 0
			comp01

<legal>

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf02.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf02"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf02 = _halide_buffer_get_host(buf02.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input03_b2[float64 * 320 * 64 * 64]
  allocate _input01_b1[float64 * 320]
  allocate _icomp00_b0[float64 * 64 * 64]
  allocate _comp01_b4[float64 * 320 * 64 * 64]
  allocate _comp00_b3[float64 * 320 * 64 * 64]
  for (c1, -63, 64) {
    for (c3, -63, 64) {
      for (c5, 0, 20) {
        unrolled (c7, 0, 16) {
          buf00[(int32((int64((0 - c1))*(int64)64)) - c3)] = ((1.000000 - (buf01[((c5*16) + c7)]*1.260000))*buf00[(int32((int64((0 - c1))*(int64)64)) - c3)])
        }
      }
      for (c5, -319, 320) {
        buf02[((int32((int64((0 - c3))*(int64)320)) - c5) + int32((int64((0 - c1))*(int64)20480)))] = (buf00[(int32((int64((0 - c1))*(int64)64)) - c3)] + buf03[((int32((int64((0 - c3))*(int64)320)) - c5) + int32((int64((0 - c1))*(int64)20480)))])
      }
    }
  }
}

<legal>
Schedule number 73
Evaluation : 1.627190
Number of measurements : 3
===================================

parallelization unrolling: .*P\(\{(C[0-9],)*C0(,C[0-9])*\},L2\)U.*|.*P\(\{(C[0-9],)*C1(,C[0-9])*\},L2\)U.*
parallelization tiling: .*P\(\{(C[0-9],)*C0(,C[0-9])*\},L2\)T2\(\{(C[0-9],)*C0(,C[0-9])*\},L0,L1.*|.*P\(\{(C[0-9],)*C1(,C[0-9])*\},L2\)T2\(\{(C[0-9],)*C1(,C[0-9])*\},L0,L1.*
else
transform_ast

-----------
Matrix Transform 3x3 {comp00, } [1, 0, 0, 0, 1, 0, 0, 0, 1]
Matrix Transform 3x3 {comp01, } [1, 0, 0, 0, 1, 0, 0, 0, 1]
Matrix Transform 2x2 {comp00, comp01, } [1, 0, 0, -1]
Matrix Transform 3x3 {comp01, } [1, 0, 0, 0, 1, 0, 0, 0, -1]
Matrix Transform 2x2 {comp00, comp01, } [-1, 0, 0, 1]
Tiling L0 32 L1 32 { comp00, comp01, }
Unrolling L4 4 { comp00, }
0- for 0 <= i0_outer < 1 | 0
	1- for 0 <= i1_outer < 1 | 0
		2- for 0 <= i0_inner < 32 | 0
			3- for 0 <= i1_inner < 32 | 0
				4- for 0 <= i2_outer < 80 | 0
					5- for 0 <= i2_inner < 4 | 1
						comp00
				4- for -319 <= i3 < 1 | 0
					comp01

<legal>

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf02.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf02"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf02 = _halide_buffer_get_host(buf02.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input03_b2[float64 * 320 * 64 * 64]
  allocate _input01_b1[float64 * 320]
  allocate _icomp00_b0[float64 * 64 * 64]
  allocate _comp01_b4[float64 * 320 * 64 * 64]
  allocate _comp00_b3[float64 * 320 * 64 * 64]
  for (c1, -2, 3) {
    for (c3, -2, 3) {
      for (c5, (-63 - min((c1*32), -63)), ((min((c1*-32), 31) + min((c1*32), -63)) + 64)) {
        for (c7, (-63 - min((c3*32), -63)), ((min((c3*-32), 31) + min((c3*32), -63)) + 64)) {
          for (c9, 0, 80) {
            unrolled (c11, 0, 4) {
              buf00[(((c3*-32) - c7) + int32((int64(((c1*-32) - c5))*(int64)64)))] = ((1.000000 - (buf01[((c9*4) + c11)]*1.260000))*buf00[(((c3*-32) - c7) + int32((int64(((c1*-32) - c5))*(int64)64)))])
            }
          }
          for (c9, -319, 320) {
            buf02[((int32((int64(((c3*-32) - c7))*(int64)320)) - c9) + int32((int64(((c1*-32) - c5))*(int64)20480)))] = (buf00[(((c3*-32) - c7) + int32((int64(((c1*-32) - c5))*(int64)64)))] + buf03[((int32((int64(((c3*-32) - c7))*(int64)320)) - c9) + int32((int64(((c1*-32) - c5))*(int64)20480)))])
          }
        }
      }
    }
  }
}

<legal>
Schedule number 74
Evaluation : 1.664690
Number of measurements : 3
===================================

parallelization unrolling: .*P\(\{(C[0-9],)*C0(,C[0-9])*\},L2\)U.*|.*P\(\{(C[0-9],)*C1(,C[0-9])*\},L2\)U.*
parallelization tiling: .*P\(\{(C[0-9],)*C0(,C[0-9])*\},L2\)T2\(\{(C[0-9],)*C0(,C[0-9])*\},L0,L1.*|.*P\(\{(C[0-9],)*C1(,C[0-9])*\},L2\)T2\(\{(C[0-9],)*C1(,C[0-9])*\},L0,L1.*
else
transform_ast

-----------
Matrix Transform 3x3 {comp00, } [1, 0, 0, 0, 1, 0, 0, 0, 1]
Matrix Transform 3x3 {comp01, } [1, 0, 0, 0, 1, 0, 0, 0, 1]
Matrix Transform 2x2 {comp00, comp01, } [1, 0, 0, -1]
Matrix Transform 3x3 {comp01, } [1, 0, 0, 0, 1, 0, 0, 0, -1]
Matrix Transform 2x2 {comp00, comp01, } [-1, 0, 0, 1]
Tiling L0 32 L1 32 { comp00, comp01, }
Unrolling L4 8 { comp00, }
0- for 0 <= i0_outer < 1 | 0
	1- for 0 <= i1_outer < 1 | 0
		2- for 0 <= i0_inner < 32 | 0
			3- for 0 <= i1_inner < 32 | 0
				4- for 0 <= i2_outer < 40 | 0
					5- for 0 <= i2_inner < 8 | 1
						comp00
				4- for -319 <= i3 < 1 | 0
					comp01

<legal>

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf02.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf02"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf02 = _halide_buffer_get_host(buf02.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input03_b2[float64 * 320 * 64 * 64]
  allocate _input01_b1[float64 * 320]
  allocate _icomp00_b0[float64 * 64 * 64]
  allocate _comp01_b4[float64 * 320 * 64 * 64]
  allocate _comp00_b3[float64 * 320 * 64 * 64]
  for (c1, -2, 3) {
    for (c3, -2, 3) {
      for (c5, (-63 - min((c1*32), -63)), ((min((c1*-32), 31) + min((c1*32), -63)) + 64)) {
        for (c7, (-63 - min((c3*32), -63)), ((min((c3*-32), 31) + min((c3*32), -63)) + 64)) {
          for (c9, 0, 40) {
            unrolled (c11, 0, 8) {
              buf00[(((c3*-32) - c7) + int32((int64(((c1*-32) - c5))*(int64)64)))] = ((1.000000 - (buf01[((c9*8) + c11)]*1.260000))*buf00[(((c3*-32) - c7) + int32((int64(((c1*-32) - c5))*(int64)64)))])
            }
          }
          for (c9, -319, 320) {
            buf02[((int32((int64(((c3*-32) - c7))*(int64)320)) - c9) + int32((int64(((c1*-32) - c5))*(int64)20480)))] = (buf00[(((c3*-32) - c7) + int32((int64(((c1*-32) - c5))*(int64)64)))] + buf03[((int32((int64(((c3*-32) - c7))*(int64)320)) - c9) + int32((int64(((c1*-32) - c5))*(int64)20480)))])
          }
        }
      }
    }
  }
}

<legal>
Schedule number 75
Evaluation : 1.423740
Number of measurements : 3
===================================

parallelization unrolling: .*P\(\{(C[0-9],)*C0(,C[0-9])*\},L2\)U.*|.*P\(\{(C[0-9],)*C1(,C[0-9])*\},L2\)U.*
parallelization tiling: .*P\(\{(C[0-9],)*C0(,C[0-9])*\},L2\)T2\(\{(C[0-9],)*C0(,C[0-9])*\},L0,L1.*|.*P\(\{(C[0-9],)*C1(,C[0-9])*\},L2\)T2\(\{(C[0-9],)*C1(,C[0-9])*\},L0,L1.*
else
transform_ast

-----------
Matrix Transform 3x3 {comp00, } [1, 0, 0, 0, 1, 0, 0, 0, 1]
Matrix Transform 3x3 {comp01, } [1, 0, 0, 0, 1, 0, 0, 0, 1]
Matrix Transform 2x2 {comp00, comp01, } [1, 0, 0, -1]
Matrix Transform 3x3 {comp01, } [1, 0, 0, 0, 1, 0, 0, 0, -1]
Matrix Transform 2x2 {comp00, comp01, } [-1, 0, 0, 1]
Tiling L0 32 L1 32 { comp00, comp01, }
Unrolling L4 16 { comp00, }
0- for 0 <= i0_outer < 1 | 0
	1- for 0 <= i1_outer < 1 | 0
		2- for 0 <= i0_inner < 32 | 0
			3- for 0 <= i1_inner < 32 | 0
				4- for 0 <= i2_outer < 20 | 0
					5- for 0 <= i2_inner < 16 | 1
						comp00
				4- for -319 <= i3 < 1 | 0
					comp01

<legal>

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf02.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf02"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf02 = _halide_buffer_get_host(buf02.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input03_b2[float64 * 320 * 64 * 64]
  allocate _input01_b1[float64 * 320]
  allocate _icomp00_b0[float64 * 64 * 64]
  allocate _comp01_b4[float64 * 320 * 64 * 64]
  allocate _comp00_b3[float64 * 320 * 64 * 64]
  for (c1, -2, 3) {
    for (c3, -2, 3) {
      for (c5, (-63 - min((c1*32), -63)), ((min((c1*-32), 31) + min((c1*32), -63)) + 64)) {
        for (c7, (-63 - min((c3*32), -63)), ((min((c3*-32), 31) + min((c3*32), -63)) + 64)) {
          for (c9, 0, 20) {
            unrolled (c11, 0, 16) {
              buf00[(((c3*-32) - c7) + int32((int64(((c1*-32) - c5))*(int64)64)))] = ((1.000000 - (buf01[((c9*16) + c11)]*1.260000))*buf00[(((c3*-32) - c7) + int32((int64(((c1*-32) - c5))*(int64)64)))])
            }
          }
          for (c9, -319, 320) {
            buf02[((int32((int64(((c3*-32) - c7))*(int64)320)) - c9) + int32((int64(((c1*-32) - c5))*(int64)20480)))] = (buf00[(((c3*-32) - c7) + int32((int64(((c1*-32) - c5))*(int64)64)))] + buf03[((int32((int64(((c3*-32) - c7))*(int64)320)) - c9) + int32((int64(((c1*-32) - c5))*(int64)20480)))])
          }
        }
      }
    }
  }
}

<legal>
Schedule number 76
Evaluation : 1.454450
Number of measurements : 3
===================================

parallelization unrolling: .*P\(\{(C[0-9],)*C0(,C[0-9])*\},L2\)U.*|.*P\(\{(C[0-9],)*C1(,C[0-9])*\},L2\)U.*
parallelization tiling: .*P\(\{(C[0-9],)*C0(,C[0-9])*\},L2\)T2\(\{(C[0-9],)*C0(,C[0-9])*\},L0,L1.*|.*P\(\{(C[0-9],)*C1(,C[0-9])*\},L2\)T2\(\{(C[0-9],)*C1(,C[0-9])*\},L0,L1.*
else
transform_ast

-----------
Matrix Transform 3x3 {comp00, } [1, 0, 0, 0, 1, 0, 0, 0, 1]
Matrix Transform 3x3 {comp01, } [1, 0, 0, 0, 1, 0, 0, 0, 1]
Matrix Transform 2x2 {comp00, comp01, } [1, 0, 0, -1]
Matrix Transform 3x3 {comp01, } [1, 0, 0, 0, 1, 0, 0, 0, -1]
Parallelize L0 { comp00, comp01, }
0- for 0 <= i0 < 64 | 0 | P
	1- for -63 <= i1 < 1 | 0
		2- for 0 <= i2 < 320 | 0
			comp00
		2- for -319 <= i3 < 1 | 0
			comp01

<legal>

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf02.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf02"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf02 = _halide_buffer_get_host(buf02.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input03_b2[float64 * 320 * 64 * 64]
  allocate _input01_b1[float64 * 320]
  allocate _icomp00_b0[float64 * 64 * 64]
  allocate _comp01_b4[float64 * 320 * 64 * 64]
  allocate _comp00_b3[float64 * 320 * 64 * 64]
  parallel (c1, 0, 64) {
    for (c3, -63, 64) {
      for (c5, 0, 320) {
        buf00[(int32((int64(c1)*(int64)64)) - c3)] = ((1.000000 - (buf01[c5]*1.260000))*buf00[(int32((int64(c1)*(int64)64)) - c3)])
      }
      for (c5, -319, 320) {
        buf02[((int32((int64((0 - c3))*(int64)320)) - c5) + int32((int64(c1)*(int64)20480)))] = (buf00[(int32((int64(c1)*(int64)64)) - c3)] + buf03[((int32((int64((0 - c3))*(int64)320)) - c5) + int32((int64(c1)*(int64)20480)))])
      }
    }
  }
}

<legal>
Schedule number 77
Evaluation : 1.542680
Number of measurements : 3
===================================

parallelization unrolling: .*P\(\{(C[0-9],)*C0(,C[0-9])*\},L2\)U.*|.*P\(\{(C[0-9],)*C1(,C[0-9])*\},L2\)U.*
parallelization tiling: .*P\(\{(C[0-9],)*C0(,C[0-9])*\},L2\)T2\(\{(C[0-9],)*C0(,C[0-9])*\},L0,L1.*|.*P\(\{(C[0-9],)*C1(,C[0-9])*\},L2\)T2\(\{(C[0-9],)*C1(,C[0-9])*\},L0,L1.*
else
transform_ast

-----------
Matrix Transform 3x3 {comp00, } [1, 0, 0, 0, 1, 0, 0, 0, 1]
Matrix Transform 3x3 {comp01, } [1, 0, 0, 0, 1, 0, 0, 0, 1]
Matrix Transform 2x2 {comp00, comp01, } [1, 0, 0, -1]
Matrix Transform 3x3 {comp01, } [1, 0, 0, 0, 1, 0, 0, 0, -1]
Parallelize L1 { comp00, comp01, }
0- for 0 <= i0 < 64 | 0
	1- for -63 <= i1 < 1 | 0 | P
		2- for 0 <= i2 < 320 | 0
			comp00
		2- for -319 <= i3 < 1 | 0
			comp01

<legal>

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf02.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf02"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf02 = _halide_buffer_get_host(buf02.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input03_b2[float64 * 320 * 64 * 64]
  allocate _input01_b1[float64 * 320]
  allocate _icomp00_b0[float64 * 64 * 64]
  allocate _comp01_b4[float64 * 320 * 64 * 64]
  allocate _comp00_b3[float64 * 320 * 64 * 64]
  for (c1, 0, 64) {
    parallel (c3, -63, 64) {
      for (c5, 0, 320) {
        buf00[(int32((int64(c1)*(int64)64)) - c3)] = ((1.000000 - (buf01[c5]*1.260000))*buf00[(int32((int64(c1)*(int64)64)) - c3)])
      }
      for (c5, -319, 320) {
        buf02[((int32((int64((0 - c3))*(int64)320)) - c5) + int32((int64(c1)*(int64)20480)))] = (buf00[(int32((int64(c1)*(int64)64)) - c3)] + buf03[((int32((int64((0 - c3))*(int64)320)) - c5) + int32((int64(c1)*(int64)20480)))])
      }
    }
  }
}

<legal>
Schedule number 78
Evaluation : 1.583880
Number of measurements : 3
===================================

parallelization unrolling: .*P\(\{(C[0-9],)*C0(,C[0-9])*\},L2\)U.*|.*P\(\{(C[0-9],)*C1(,C[0-9])*\},L2\)U.*
parallelization tiling: .*P\(\{(C[0-9],)*C0(,C[0-9])*\},L2\)T2\(\{(C[0-9],)*C0(,C[0-9])*\},L0,L1.*|.*P\(\{(C[0-9],)*C1(,C[0-9])*\},L2\)T2\(\{(C[0-9],)*C1(,C[0-9])*\},L0,L1.*
else
transform_ast

-----------
Matrix Transform 3x3 {comp00, } [1, 0, 0, 0, 1, 0, 0, 0, 1]
Matrix Transform 3x3 {comp01, } [1, 0, 0, 0, 1, 0, 0, 0, 1]
Matrix Transform 2x2 {comp00, comp01, } [1, 0, 0, -1]
Matrix Transform 3x3 {comp01, } [1, 0, 0, 0, 1, 0, 0, 0, -1]
Parallelize L2 { comp01, }
0- for 0 <= i0 < 64 | 0
	1- for -63 <= i1 < 1 | 0
		2- for 0 <= i2 < 320 | 0
			comp00
		2- for -319 <= i3 < 1 | 0 | P
			comp01

<legal>
set to default

<legal>
Schedule number 79
Evaluation : 0.000000
Number of measurements : 1
===================================

parallelization unrolling: .*P\(\{(C[0-9],)*C0(,C[0-9])*\},L2\)U.*|.*P\(\{(C[0-9],)*C1(,C[0-9])*\},L2\)U.*
parallelization tiling: .*P\(\{(C[0-9],)*C0(,C[0-9])*\},L2\)T2\(\{(C[0-9],)*C0(,C[0-9])*\},L0,L1.*|.*P\(\{(C[0-9],)*C1(,C[0-9])*\},L2\)T2\(\{(C[0-9],)*C1(,C[0-9])*\},L0,L1.*
if

-----------
Matrix Transform 3x3 {comp00, } [1, 0, 0, 0, 1, 0, 0, 0, 1]
Matrix Transform 3x3 {comp01, } [1, 0, 0, 0, 1, 0, 0, 0, 1]
Matrix Transform 2x2 {comp00, comp01, } [1, 0, 0, -1]
Matrix Transform 3x3 {comp01, } [1, 0, 0, 0, 1, 0, 0, 0, -1]
Parallelize L2 { comp01, }
Tiling L0 32 L1 32 { comp00, comp01, }
0- for 0 <= i0 < 64 | 0
	1- for -63 <= i1 < 1 | 0
		2- for 0 <= i2 < 320 | 0
			comp00
		2- for -319 <= i3 < 1 | 0 | P
			comp01

<Schedule pruned>
parallelization unrolling: .*P\(\{(C[0-9],)*C0(,C[0-9])*\},L2\)U.*|.*P\(\{(C[0-9],)*C1(,C[0-9])*\},L2\)U.*
if

-----------
Matrix Transform 3x3 {comp00, } [1, 0, 0, 0, 1, 0, 0, 0, 1]
Matrix Transform 3x3 {comp01, } [1, 0, 0, 0, 1, 0, 0, 0, 1]
Matrix Transform 2x2 {comp00, comp01, } [1, 0, 0, -1]
Matrix Transform 3x3 {comp01, } [1, 0, 0, 0, 1, 0, 0, 0, -1]
Parallelize L2 { comp01, }
Unrolling L2 4 { comp00, }
0- for 0 <= i0 < 64 | 0
	1- for -63 <= i1 < 1 | 0
		2- for 0 <= i2 < 320 | 0
			comp00
		2- for -319 <= i3 < 1 | 0 | P
			comp01

<Schedule pruned>
parallelization unrolling: .*P\(\{(C[0-9],)*C0(,C[0-9])*\},L2\)U.*|.*P\(\{(C[0-9],)*C1(,C[0-9])*\},L2\)U.*
if

-----------
Matrix Transform 3x3 {comp00, } [1, 0, 0, 0, 1, 0, 0, 0, 1]
Matrix Transform 3x3 {comp01, } [1, 0, 0, 0, 1, 0, 0, 0, 1]
Matrix Transform 2x2 {comp00, comp01, } [1, 0, 0, -1]
Matrix Transform 3x3 {comp01, } [1, 0, 0, 0, 1, 0, 0, 0, -1]
Parallelize L2 { comp01, }
Unrolling L2 8 { comp00, }
0- for 0 <= i0 < 64 | 0
	1- for -63 <= i1 < 1 | 0
		2- for 0 <= i2 < 320 | 0
			comp00
		2- for -319 <= i3 < 1 | 0 | P
			comp01

<Schedule pruned>
parallelization unrolling: .*P\(\{(C[0-9],)*C0(,C[0-9])*\},L2\)U.*|.*P\(\{(C[0-9],)*C1(,C[0-9])*\},L2\)U.*
if

-----------
Matrix Transform 3x3 {comp00, } [1, 0, 0, 0, 1, 0, 0, 0, 1]
Matrix Transform 3x3 {comp01, } [1, 0, 0, 0, 1, 0, 0, 0, 1]
Matrix Transform 2x2 {comp00, comp01, } [1, 0, 0, -1]
Matrix Transform 3x3 {comp01, } [1, 0, 0, 0, 1, 0, 0, 0, -1]
Parallelize L2 { comp01, }
Unrolling L2 16 { comp00, }
0- for 0 <= i0 < 64 | 0
	1- for -63 <= i1 < 1 | 0
		2- for 0 <= i2 < 320 | 0
			comp00
		2- for -319 <= i3 < 1 | 0 | P
			comp01

<Schedule pruned>
parallelization unrolling: .*P\(\{(C[0-9],)*C0(,C[0-9])*\},L2\)U.*|.*P\(\{(C[0-9],)*C1(,C[0-9])*\},L2\)U.*
parallelization tiling: .*P\(\{(C[0-9],)*C0(,C[0-9])*\},L2\)T2\(\{(C[0-9],)*C0(,C[0-9])*\},L0,L1.*|.*P\(\{(C[0-9],)*C1(,C[0-9])*\},L2\)T2\(\{(C[0-9],)*C1(,C[0-9])*\},L0,L1.*
else
transform_ast

-----------
Matrix Transform 3x3 {comp00, } [1, 0, 0, 0, 1, 0, 0, 0, 1]
Matrix Transform 3x3 {comp01, } [1, 0, 0, 0, 1, 0, 0, 0, 1]
Matrix Transform 2x2 {comp00, comp01, } [1, 0, 0, -1]
Matrix Transform 3x3 {comp01, } [1, 0, 0, 0, 1, 0, 0, 0, -1]
Tiling L0 32 L1 32 { comp00, comp01, }
0- for 0 <= i0_outer < 2 | 0
	1- for 0 <= i1_outer < 1 | 0
		2- for 0 <= i0_inner < 32 | 0
			3- for 0 <= i1_inner < 32 | 0
				4- for 0 <= i2 < 320 | 0
					comp00
				4- for -319 <= i3 < 1 | 0
					comp01

<legal>

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf02.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf02"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf02 = _halide_buffer_get_host(buf02.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input03_b2[float64 * 320 * 64 * 64]
  allocate _input01_b1[float64 * 320]
  allocate _icomp00_b0[float64 * 64 * 64]
  allocate _comp01_b4[float64 * 320 * 64 * 64]
  allocate _comp00_b3[float64 * 320 * 64 * 64]
  for (c1, 0, 2) {
    for (c3, -2, 3) {
      for (c5, 0, 32) {
        for (c7, (-63 - min((c3*32), -63)), ((min((c3*-32), 31) + min((c3*32), -63)) + 64)) {
          for (c9, 0, 320) {
            buf00[(((c3*-32) - c7) + int32((int64(((c1*32) + c5))*(int64)64)))] = ((1.000000 - (buf01[c9]*1.260000))*buf00[(((c3*-32) - c7) + int32((int64(((c1*32) + c5))*(int64)64)))])
          }
          for (c9, -319, 320) {
            buf02[((int32((int64(((c3*-32) - c7))*(int64)320)) - c9) + int32((int64(((c1*32) + c5))*(int64)20480)))] = (buf00[(((c3*-32) - c7) + int32((int64(((c1*32) + c5))*(int64)64)))] + buf03[((int32((int64(((c3*-32) - c7))*(int64)320)) - c9) + int32((int64(((c1*32) + c5))*(int64)20480)))])
          }
        }
      }
    }
  }
}

<legal>
Schedule number 80
Evaluation : 1.507260
Number of measurements : 3
===================================

parallelization unrolling: .*P\(\{(C[0-9],)*C0(,C[0-9])*\},L2\)U.*|.*P\(\{(C[0-9],)*C1(,C[0-9])*\},L2\)U.*
parallelization tiling: .*P\(\{(C[0-9],)*C0(,C[0-9])*\},L2\)T2\(\{(C[0-9],)*C0(,C[0-9])*\},L0,L1.*|.*P\(\{(C[0-9],)*C1(,C[0-9])*\},L2\)T2\(\{(C[0-9],)*C1(,C[0-9])*\},L0,L1.*
else
transform_ast

-----------
Matrix Transform 3x3 {comp00, } [1, 0, 0, 0, 1, 0, 0, 0, 1]
Matrix Transform 3x3 {comp01, } [1, 0, 0, 0, 1, 0, 0, 0, 1]
Matrix Transform 2x2 {comp00, comp01, } [1, 0, 0, -1]
Matrix Transform 3x3 {comp01, } [1, 0, 0, 0, 1, 0, 0, 0, -1]
Unrolling L2 4 { comp00, }
0- for 0 <= i0 < 64 | 0
	1- for -63 <= i1 < 1 | 0
		2- for 0 <= i2_outer < 80 | 0
			3- for 0 <= i2_inner < 4 | 1
				comp00
		2- for -319 <= i3 < 1 | 0
			comp01

<legal>

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf02.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf02"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf02 = _halide_buffer_get_host(buf02.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input03_b2[float64 * 320 * 64 * 64]
  allocate _input01_b1[float64 * 320]
  allocate _icomp00_b0[float64 * 64 * 64]
  allocate _comp01_b4[float64 * 320 * 64 * 64]
  allocate _comp00_b3[float64 * 320 * 64 * 64]
  for (c1, 0, 64) {
    for (c3, -63, 64) {
      for (c5, 0, 80) {
        unrolled (c7, 0, 4) {
          buf00[(int32((int64(c1)*(int64)64)) - c3)] = ((1.000000 - (buf01[((c5*4) + c7)]*1.260000))*buf00[(int32((int64(c1)*(int64)64)) - c3)])
        }
      }
      for (c5, -319, 320) {
        buf02[((int32((int64((0 - c3))*(int64)320)) - c5) + int32((int64(c1)*(int64)20480)))] = (buf00[(int32((int64(c1)*(int64)64)) - c3)] + buf03[((int32((int64((0 - c3))*(int64)320)) - c5) + int32((int64(c1)*(int64)20480)))])
      }
    }
  }
}

<legal>
Schedule number 81
Evaluation : 1.355690
Number of measurements : 3
===================================

parallelization unrolling: .*P\(\{(C[0-9],)*C0(,C[0-9])*\},L2\)U.*|.*P\(\{(C[0-9],)*C1(,C[0-9])*\},L2\)U.*
parallelization tiling: .*P\(\{(C[0-9],)*C0(,C[0-9])*\},L2\)T2\(\{(C[0-9],)*C0(,C[0-9])*\},L0,L1.*|.*P\(\{(C[0-9],)*C1(,C[0-9])*\},L2\)T2\(\{(C[0-9],)*C1(,C[0-9])*\},L0,L1.*
else
transform_ast

-----------
Matrix Transform 3x3 {comp00, } [1, 0, 0, 0, 1, 0, 0, 0, 1]
Matrix Transform 3x3 {comp01, } [1, 0, 0, 0, 1, 0, 0, 0, 1]
Matrix Transform 2x2 {comp00, comp01, } [1, 0, 0, -1]
Matrix Transform 3x3 {comp01, } [1, 0, 0, 0, 1, 0, 0, 0, -1]
Unrolling L2 8 { comp00, }
0- for 0 <= i0 < 64 | 0
	1- for -63 <= i1 < 1 | 0
		2- for 0 <= i2_outer < 40 | 0
			3- for 0 <= i2_inner < 8 | 1
				comp00
		2- for -319 <= i3 < 1 | 0
			comp01

<legal>

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf02.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf02"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf02 = _halide_buffer_get_host(buf02.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input03_b2[float64 * 320 * 64 * 64]
  allocate _input01_b1[float64 * 320]
  allocate _icomp00_b0[float64 * 64 * 64]
  allocate _comp01_b4[float64 * 320 * 64 * 64]
  allocate _comp00_b3[float64 * 320 * 64 * 64]
  for (c1, 0, 64) {
    for (c3, -63, 64) {
      for (c5, 0, 40) {
        unrolled (c7, 0, 8) {
          buf00[(int32((int64(c1)*(int64)64)) - c3)] = ((1.000000 - (buf01[((c5*8) + c7)]*1.260000))*buf00[(int32((int64(c1)*(int64)64)) - c3)])
        }
      }
      for (c5, -319, 320) {
        buf02[((int32((int64((0 - c3))*(int64)320)) - c5) + int32((int64(c1)*(int64)20480)))] = (buf00[(int32((int64(c1)*(int64)64)) - c3)] + buf03[((int32((int64((0 - c3))*(int64)320)) - c5) + int32((int64(c1)*(int64)20480)))])
      }
    }
  }
}

<legal>
Schedule number 82
Evaluation : 1.237180
Number of measurements : 3
===================================

parallelization unrolling: .*P\(\{(C[0-9],)*C0(,C[0-9])*\},L2\)U.*|.*P\(\{(C[0-9],)*C1(,C[0-9])*\},L2\)U.*
parallelization tiling: .*P\(\{(C[0-9],)*C0(,C[0-9])*\},L2\)T2\(\{(C[0-9],)*C0(,C[0-9])*\},L0,L1.*|.*P\(\{(C[0-9],)*C1(,C[0-9])*\},L2\)T2\(\{(C[0-9],)*C1(,C[0-9])*\},L0,L1.*
else
transform_ast

-----------
Matrix Transform 3x3 {comp00, } [1, 0, 0, 0, 1, 0, 0, 0, 1]
Matrix Transform 3x3 {comp01, } [1, 0, 0, 0, 1, 0, 0, 0, 1]
Matrix Transform 2x2 {comp00, comp01, } [1, 0, 0, -1]
Matrix Transform 3x3 {comp01, } [1, 0, 0, 0, 1, 0, 0, 0, -1]
Unrolling L2 16 { comp00, }
0- for 0 <= i0 < 64 | 0
	1- for -63 <= i1 < 1 | 0
		2- for 0 <= i2_outer < 20 | 0
			3- for 0 <= i2_inner < 16 | 1
				comp00
		2- for -319 <= i3 < 1 | 0
			comp01

<legal>

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf02.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf02"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf02 = _halide_buffer_get_host(buf02.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input03_b2[float64 * 320 * 64 * 64]
  allocate _input01_b1[float64 * 320]
  allocate _icomp00_b0[float64 * 64 * 64]
  allocate _comp01_b4[float64 * 320 * 64 * 64]
  allocate _comp00_b3[float64 * 320 * 64 * 64]
  for (c1, 0, 64) {
    for (c3, -63, 64) {
      for (c5, 0, 20) {
        unrolled (c7, 0, 16) {
          buf00[(int32((int64(c1)*(int64)64)) - c3)] = ((1.000000 - (buf01[((c5*16) + c7)]*1.260000))*buf00[(int32((int64(c1)*(int64)64)) - c3)])
        }
      }
      for (c5, -319, 320) {
        buf02[((int32((int64((0 - c3))*(int64)320)) - c5) + int32((int64(c1)*(int64)20480)))] = (buf00[(int32((int64(c1)*(int64)64)) - c3)] + buf03[((int32((int64((0 - c3))*(int64)320)) - c5) + int32((int64(c1)*(int64)20480)))])
      }
    }
  }
}

<legal>
Schedule number 83
Evaluation : 1.465000
Number of measurements : 3
===================================

parallelization unrolling: .*P\(\{(C[0-9],)*C0(,C[0-9])*\},L2\)U.*|.*P\(\{(C[0-9],)*C1(,C[0-9])*\},L2\)U.*
parallelization tiling: .*P\(\{(C[0-9],)*C0(,C[0-9])*\},L2\)T2\(\{(C[0-9],)*C0(,C[0-9])*\},L0,L1.*|.*P\(\{(C[0-9],)*C1(,C[0-9])*\},L2\)T2\(\{(C[0-9],)*C1(,C[0-9])*\},L0,L1.*
else
transform_ast

-----------
Matrix Transform 3x3 {comp00, } [1, 0, 0, 0, 1, 0, 0, 0, 1]
Matrix Transform 3x3 {comp01, } [1, 0, 0, 0, 1, 0, 0, 0, 1]
Matrix Transform 2x2 {comp00, comp01, } [1, 0, 0, -1]
Matrix Transform 3x3 {comp01, } [1, 0, 0, 0, 1, 0, 0, 0, -1]
Tiling L0 32 L1 32 { comp00, comp01, }
Unrolling L4 4 { comp00, }
0- for 0 <= i0_outer < 2 | 0
	1- for 0 <= i1_outer < 1 | 0
		2- for 0 <= i0_inner < 32 | 0
			3- for 0 <= i1_inner < 32 | 0
				4- for 0 <= i2_outer < 80 | 0
					5- for 0 <= i2_inner < 4 | 1
						comp00
				4- for -319 <= i3 < 1 | 0
					comp01

<legal>

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf02.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf02"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf02 = _halide_buffer_get_host(buf02.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input03_b2[float64 * 320 * 64 * 64]
  allocate _input01_b1[float64 * 320]
  allocate _icomp00_b0[float64 * 64 * 64]
  allocate _comp01_b4[float64 * 320 * 64 * 64]
  allocate _comp00_b3[float64 * 320 * 64 * 64]
  for (c1, 0, 2) {
    for (c3, -2, 3) {
      for (c5, 0, 32) {
        for (c7, (-63 - min((c3*32), -63)), ((min((c3*-32), 31) + min((c3*32), -63)) + 64)) {
          for (c9, 0, 80) {
            unrolled (c11, 0, 4) {
              buf00[(((c3*-32) - c7) + int32((int64(((c1*32) + c5))*(int64)64)))] = ((1.000000 - (buf01[((c9*4) + c11)]*1.260000))*buf00[(((c3*-32) - c7) + int32((int64(((c1*32) + c5))*(int64)64)))])
            }
          }
          for (c9, -319, 320) {
            buf02[((int32((int64(((c3*-32) - c7))*(int64)320)) - c9) + int32((int64(((c1*32) + c5))*(int64)20480)))] = (buf00[(((c3*-32) - c7) + int32((int64(((c1*32) + c5))*(int64)64)))] + buf03[((int32((int64(((c3*-32) - c7))*(int64)320)) - c9) + int32((int64(((c1*32) + c5))*(int64)20480)))])
          }
        }
      }
    }
  }
}

<legal>
Schedule number 84
Evaluation : 1.371460
Number of measurements : 3
===================================

parallelization unrolling: .*P\(\{(C[0-9],)*C0(,C[0-9])*\},L2\)U.*|.*P\(\{(C[0-9],)*C1(,C[0-9])*\},L2\)U.*
parallelization tiling: .*P\(\{(C[0-9],)*C0(,C[0-9])*\},L2\)T2\(\{(C[0-9],)*C0(,C[0-9])*\},L0,L1.*|.*P\(\{(C[0-9],)*C1(,C[0-9])*\},L2\)T2\(\{(C[0-9],)*C1(,C[0-9])*\},L0,L1.*
else
transform_ast

-----------
Matrix Transform 3x3 {comp00, } [1, 0, 0, 0, 1, 0, 0, 0, 1]
Matrix Transform 3x3 {comp01, } [1, 0, 0, 0, 1, 0, 0, 0, 1]
Matrix Transform 2x2 {comp00, comp01, } [1, 0, 0, -1]
Matrix Transform 3x3 {comp01, } [1, 0, 0, 0, 1, 0, 0, 0, -1]
Tiling L0 32 L1 32 { comp00, comp01, }
Unrolling L4 8 { comp00, }
0- for 0 <= i0_outer < 2 | 0
	1- for 0 <= i1_outer < 1 | 0
		2- for 0 <= i0_inner < 32 | 0
			3- for 0 <= i1_inner < 32 | 0
				4- for 0 <= i2_outer < 40 | 0
					5- for 0 <= i2_inner < 8 | 1
						comp00
				4- for -319 <= i3 < 1 | 0
					comp01

<legal>

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf02.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf02"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf02 = _halide_buffer_get_host(buf02.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input03_b2[float64 * 320 * 64 * 64]
  allocate _input01_b1[float64 * 320]
  allocate _icomp00_b0[float64 * 64 * 64]
  allocate _comp01_b4[float64 * 320 * 64 * 64]
  allocate _comp00_b3[float64 * 320 * 64 * 64]
  for (c1, 0, 2) {
    for (c3, -2, 3) {
      for (c5, 0, 32) {
        for (c7, (-63 - min((c3*32), -63)), ((min((c3*-32), 31) + min((c3*32), -63)) + 64)) {
          for (c9, 0, 40) {
            unrolled (c11, 0, 8) {
              buf00[(((c3*-32) - c7) + int32((int64(((c1*32) + c5))*(int64)64)))] = ((1.000000 - (buf01[((c9*8) + c11)]*1.260000))*buf00[(((c3*-32) - c7) + int32((int64(((c1*32) + c5))*(int64)64)))])
            }
          }
          for (c9, -319, 320) {
            buf02[((int32((int64(((c3*-32) - c7))*(int64)320)) - c9) + int32((int64(((c1*32) + c5))*(int64)20480)))] = (buf00[(((c3*-32) - c7) + int32((int64(((c1*32) + c5))*(int64)64)))] + buf03[((int32((int64(((c3*-32) - c7))*(int64)320)) - c9) + int32((int64(((c1*32) + c5))*(int64)20480)))])
          }
        }
      }
    }
  }
}

<legal>
Schedule number 85
Evaluation : 1.502750
Number of measurements : 3
===================================

parallelization unrolling: .*P\(\{(C[0-9],)*C0(,C[0-9])*\},L2\)U.*|.*P\(\{(C[0-9],)*C1(,C[0-9])*\},L2\)U.*
parallelization tiling: .*P\(\{(C[0-9],)*C0(,C[0-9])*\},L2\)T2\(\{(C[0-9],)*C0(,C[0-9])*\},L0,L1.*|.*P\(\{(C[0-9],)*C1(,C[0-9])*\},L2\)T2\(\{(C[0-9],)*C1(,C[0-9])*\},L0,L1.*
else
transform_ast

-----------
Matrix Transform 3x3 {comp00, } [1, 0, 0, 0, 1, 0, 0, 0, 1]
Matrix Transform 3x3 {comp01, } [1, 0, 0, 0, 1, 0, 0, 0, 1]
Matrix Transform 2x2 {comp00, comp01, } [1, 0, 0, -1]
Matrix Transform 3x3 {comp01, } [1, 0, 0, 0, 1, 0, 0, 0, -1]
Tiling L0 32 L1 32 { comp00, comp01, }
Unrolling L4 16 { comp00, }
0- for 0 <= i0_outer < 2 | 0
	1- for 0 <= i1_outer < 1 | 0
		2- for 0 <= i0_inner < 32 | 0
			3- for 0 <= i1_inner < 32 | 0
				4- for 0 <= i2_outer < 20 | 0
					5- for 0 <= i2_inner < 16 | 1
						comp00
				4- for -319 <= i3 < 1 | 0
					comp01

<legal>

Generated Halide IR:
assert((reinterpret(uint64, buf03.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf03"))
assert((reinterpret(uint64, buf02.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf02"))
assert((reinterpret(uint64, buf01.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf01"))
assert((reinterpret(uint64, buf00.buffer) != (uint64)0), halide_error_buffer_argument_is_null("buf00"))
let buf00 = _halide_buffer_get_host(buf00.buffer)
let buf01 = _halide_buffer_get_host(buf01.buffer)
let buf02 = _halide_buffer_get_host(buf02.buffer)
let buf03 = _halide_buffer_get_host(buf03.buffer)
produce  {
  allocate _input03_b2[float64 * 320 * 64 * 64]
  allocate _input01_b1[float64 * 320]
  allocate _icomp00_b0[float64 * 64 * 64]
  allocate _comp01_b4[float64 * 320 * 64 * 64]
  allocate _comp00_b3[float64 * 320 * 64 * 64]
  for (c1, 0, 2) {
    for (c3, -2, 3) {
      for (c5, 0, 32) {
        for (c7, (-63 - min((c3*32), -63)), ((min((c3*-32), 31) + min((c3*32), -63)) + 64)) {
          for (c9, 0, 20) {
            unrolled (c11, 0, 16) {
              buf00[(((c3*-32) - c7) + int32((int64(((c1*32) + c5))*(int64)64)))] = ((1.000000 - (buf01[((c9*16) + c11)]*1.260000))*buf00[(((c3*-32) - c7) + int32((int64(((c1*32) + c5))*(int64)64)))])
            }
          }
          for (c9, -319, 320) {
            buf02[((int32((int64(((c3*-32) - c7))*(int64)320)) - c9) + int32((int64(((c1*32) + c5))*(int64)20480)))] = (buf00[(((c3*-32) - c7) + int32((int64(((c1*32) + c5))*(int64)64)))] + buf03[((int32((int64(((c3*-32) - c7))*(int64)320)) - c9) + int32((int64(((c1*32) + c5))*(int64)20480)))])
          }
        }
      }
    }
  }
}

<legal>
Schedule number 86
Evaluation : 1.280100
Number of measurements : 3
===================================

Search time : 148376 ms
Best execution time : 0.000000
